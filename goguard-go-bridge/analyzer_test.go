package main

import (
	"os"
	"path/filepath"
	"testing"
	"time"

	ir "github.com/goguard/goguard-go-bridge/flatbuffers/goguard/ir"
)

func TestCompileSimpleProject(t *testing.T) {
	// Create a temporary Go project
	dir := t.TempDir()

	// Write go.mod
	gomod := `module testproject
go 1.21
`
	if err := os.WriteFile(filepath.Join(dir, "go.mod"), []byte(gomod), 0644); err != nil {
		t.Fatal(err)
	}

	// Write a simple Go file
	src := `package main

import "fmt"

type User struct {
	Name string
}

func GetUser(id int) (*User, error) {
	if id <= 0 {
		return nil, fmt.Errorf("invalid id: %d", id)
	}
	return &User{Name: "test"}, nil
}

func main() {
	user, err := GetUser(42)
	if err != nil {
		fmt.Println("error:", err)
	}
	fmt.Println(user.Name)
}
`
	if err := os.WriteFile(filepath.Join(dir, "main.go"), []byte(src), 0644); err != nil {
		t.Fatal(err)
	}

	result, err := Compile(dir, []string{"./..."})
	if err != nil {
		t.Fatalf("Compile failed: %v", err)
	}

	if len(result.Packages) == 0 {
		t.Fatal("expected at least one package")
	}

	pkg := result.Packages[0]
	if pkg.Name != "main" {
		t.Errorf("expected package name 'main', got %q", pkg.Name)
	}

	// Find GetUser function
	var getUserFunc *FunctionIR
	for i := range pkg.Functions {
		if pkg.Functions[i].ShortName == "GetUser" {
			getUserFunc = &pkg.Functions[i]
			break
		}
	}
	if getUserFunc == nil {
		t.Fatal("expected to find GetUser function")
	}

	if len(getUserFunc.Blocks) == 0 {
		t.Error("expected GetUser to have basic blocks")
	}

	if len(getUserFunc.CfgEdges) == 0 {
		t.Error("expected GetUser to have CFG edges (if/else branching)")
	}

	// Verify types are registered
	if len(pkg.Types) == 0 {
		t.Error("expected types to be registered")
	}
}

func TestParameterInstructionsEmitted(t *testing.T) {
	dir := t.TempDir()
	gomod := "module testproject\ngo 1.21\n"
	os.WriteFile(filepath.Join(dir, "go.mod"), []byte(gomod), 0644)

	src := `package main

type Handler struct {
	svc string
}

func NewHandler(s string) *Handler {
	return &Handler{svc: s}
}

func (h *Handler) DoWork() string {
	return h.svc
}

func main() {
	h := NewHandler("test")
	_ = h.DoWork()
}
`
	os.WriteFile(filepath.Join(dir, "main.go"), []byte(src), 0644)

	result, err := Compile(dir, []string{"./..."})
	if err != nil {
		t.Fatalf("Compile: %v", err)
	}

	pkg := result.Packages[0]

	// Find DoWork method
	var doWork *FunctionIR
	for i := range pkg.Functions {
		if pkg.Functions[i].ShortName == "DoWork" {
			doWork = &pkg.Functions[i]
			break
		}
	}
	if doWork == nil {
		t.Fatal("DoWork not found")
	}

	if !doWork.IsMethod {
		t.Error("DoWork should be marked as method")
	}

	// Check that entry block has Parameter instructions
	if len(doWork.Blocks) == 0 {
		t.Fatal("no blocks")
	}
	entryBlock := doWork.Blocks[0]
	paramCount := 0
	for _, instr := range entryBlock.Instructions {
		t.Logf("instr: id=%d kind=%s name=%s", instr.ID, instr.Kind, instr.Name)
		if instr.Kind == "Parameter" {
			paramCount++
		}
	}
	if paramCount == 0 {
		t.Errorf("expected Parameter instructions in entry block, found 0 (total instrs: %d)", len(entryBlock.Instructions))
	} else {
		t.Logf("found %d Parameter instructions", paramCount)
	}
}

func TestCompileDetectsGeneratedCode(t *testing.T) {
	dir := t.TempDir()

	gomod := `module testproject
go 1.21
`
	os.WriteFile(filepath.Join(dir, "go.mod"), []byte(gomod), 0644)

	// Regular file
	regular := `package main

func Hello() string { return "hello" }
`
	os.WriteFile(filepath.Join(dir, "hello.go"), []byte(regular), 0644)

	// Generated file
	generated := `// Code generated by protoc-gen-go. DO NOT EDIT.
package main

func GeneratedFunc() {}
`
	os.WriteFile(filepath.Join(dir, "generated.pb.go"), []byte(generated), 0644)

	result, err := Compile(dir, []string{"./..."})
	if err != nil {
		t.Fatalf("Compile failed: %v", err)
	}

	pkg := result.Packages[0]

	foundGenerated := false
	for _, f := range pkg.Files {
		if f.IsGenerated {
			foundGenerated = true
			break
		}
	}
	if !foundGenerated {
		t.Error("expected to detect generated file")
	}
}

func TestGeneratedFileDetection(t *testing.T) {
	tests := []struct {
		name     string
		filename string
		content  string
		want     bool
	}{
		{"pb.go suffix", "types.pb.go", "package main", true},
		{"gen.go suffix", "types.gen.go", "package main", true},
		{"generated suffix", "types_generated.go", "package main", true},
		{"string suffix", "types_string.go", "package main", true},
		{"normal file", "main.go", "package main", false},
		{"code generated comment", "codegen.go", "// Code generated by tool. DO NOT EDIT.\npackage main", true},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			dir := t.TempDir()
			path := filepath.Join(dir, tt.filename)
			os.WriteFile(path, []byte(tt.content), 0644)

			got := IsGeneratedFile(path)
			if got != tt.want {
				t.Errorf("IsGeneratedFile(%q) = %v, want %v", tt.filename, got, tt.want)
			}
		})
	}
}

func TestSSABlocksAndEdges(t *testing.T) {
	dir := t.TempDir()

	gomod := `module testproject
go 1.21
`
	os.WriteFile(filepath.Join(dir, "go.mod"), []byte(gomod), 0644)

	// Function with if/else to test CFG edges
	src := `package main

func Classify(n int) string {
	if n > 0 {
		return "positive"
	} else if n < 0 {
		return "negative"
	}
	return "zero"
}
`
	os.WriteFile(filepath.Join(dir, "classify.go"), []byte(src), 0644)

	result, err := Compile(dir, []string{"./..."})
	if err != nil {
		t.Fatalf("Compile failed: %v", err)
	}

	pkg := result.Packages[0]
	var classifyFunc *FunctionIR
	for i := range pkg.Functions {
		if pkg.Functions[i].ShortName == "Classify" {
			classifyFunc = &pkg.Functions[i]
			break
		}
	}
	if classifyFunc == nil {
		t.Fatal("expected to find Classify function")
	}

	// Should have multiple blocks due to if/else
	if len(classifyFunc.Blocks) < 3 {
		t.Errorf("expected at least 3 basic blocks for if/else, got %d", len(classifyFunc.Blocks))
	}

	// Should have CFG edges
	if len(classifyFunc.CfgEdges) < 2 {
		t.Errorf("expected at least 2 CFG edges, got %d", len(classifyFunc.CfgEdges))
	}

	// Check for conditional edges
	hasCondTrue := false
	hasCondFalse := false
	for _, edge := range classifyFunc.CfgEdges {
		if edge.Kind == "CondTrue" {
			hasCondTrue = true
		}
		if edge.Kind == "CondFalse" {
			hasCondFalse = true
		}
	}
	if !hasCondTrue || !hasCondFalse {
		t.Error("expected both CondTrue and CondFalse edges")
	}
}

// setupMinimalGoProject creates a temp dir with go.mod and a single main.go file.
// Returns the project dir path. The caller can modify files in the dir for tests.
func setupMinimalGoProject(t *testing.T) string {
	t.Helper()
	dir := t.TempDir()

	gomod := `module cachetest
go 1.21
`
	if err := os.WriteFile(filepath.Join(dir, "go.mod"), []byte(gomod), 0644); err != nil {
		t.Fatal(err)
	}

	src := `package main

func Add(a, b int) int { return a + b }
`
	if err := os.WriteFile(filepath.Join(dir, "main.go"), []byte(src), 0644); err != nil {
		t.Fatal(err)
	}

	return dir
}

func TestCompileWithCache_NoDir(t *testing.T) {
	dir := setupMinimalGoProject(t)

	// Empty cacheDir should fall through to Compile() directly
	result, err := CompileWithCache(dir, []string{"./..."}, "", 20)
	if err != nil {
		t.Fatalf("CompileWithCache with empty cacheDir failed: %v", err)
	}
	if result == nil {
		t.Fatal("expected non-nil CompileResult when cacheDir is empty")
	}
	if len(result.Packages) == 0 {
		t.Fatal("expected at least one package")
	}
}

func TestCompileWithCache_CacheHitOnSecondCall(t *testing.T) {
	dir := setupMinimalGoProject(t)
	cacheDir := t.TempDir()

	// First call — cache miss, should return CompileResult
	result1, err1 := CompileWithCache(dir, []string{"./..."}, cacheDir, 20)
	if err1 != nil {
		t.Fatalf("first CompileWithCache failed: %v", err1)
	}
	if result1 == nil {
		t.Fatal("first call should return CompileResult, got nil")
	}

	// Build the expected FlatBuffers payload for comparison
	expectedFB := BuildFlatBuffers(result1)

	// Second call — same files, should be a cache hit
	result2, err2 := CompileWithCache(dir, []string{"./..."}, cacheDir, 20)
	if result2 != nil {
		t.Fatal("second call should return nil CompileResult on cache hit")
	}
	if err2 == nil {
		t.Fatal("second call should return CacheHit error")
	}

	hit, ok := err2.(*CacheHit)
	if !ok {
		t.Fatalf("second call error should be *CacheHit, got %T: %v", err2, err2)
	}

	if len(hit.Payload) == 0 {
		t.Fatal("CacheHit payload should not be empty")
	}

	// The cached payload should match the FlatBuffers built from the first call
	if len(hit.Payload) != len(expectedFB) {
		t.Errorf("cached payload size %d != expected %d", len(hit.Payload), len(expectedFB))
	}

	if hit.Fingerprint == "" {
		t.Error("CacheHit fingerprint should not be empty")
	}
}

func TestCompileWithCache_InvalidatesOnFileChange(t *testing.T) {
	dir := setupMinimalGoProject(t)
	cacheDir := t.TempDir()

	// First call — populates cache
	result1, err1 := CompileWithCache(dir, []string{"./..."}, cacheDir, 20)
	if err1 != nil {
		t.Fatalf("first CompileWithCache failed: %v", err1)
	}
	if result1 == nil {
		t.Fatal("first call should return CompileResult")
	}

	// Modify the source file — change Add to Multiply.
	// Sleep briefly to ensure mtime changes (some filesystems have 1s resolution).
	time.Sleep(50 * time.Millisecond)

	newSrc := `package main

func Multiply(a, b int) int { return a * b }
`
	if err := os.WriteFile(filepath.Join(dir, "main.go"), []byte(newSrc), 0644); err != nil {
		t.Fatal(err)
	}

	// Second call — file changed, should NOT return CacheHit
	result2, err2 := CompileWithCache(dir, []string{"./..."}, cacheDir, 20)
	if err2 != nil {
		// If it's a CacheHit, the test fails — the file changed so cache should miss
		if _, ok := err2.(*CacheHit); ok {
			t.Fatal("expected cache miss after file change, but got CacheHit")
		}
		t.Fatalf("second CompileWithCache failed: %v", err2)
	}
	if result2 == nil {
		t.Fatal("second call should return CompileResult after file change")
	}

	// Verify the new compilation actually has the new function
	found := false
	for _, pkg := range result2.Packages {
		for _, fn := range pkg.Functions {
			if fn.ShortName == "Multiply" {
				found = true
				break
			}
		}
	}
	if !found {
		t.Error("expected to find Multiply function in recompiled result")
	}
}

func TestParameterInstructionsInFlatBuffers(t *testing.T) {
	dir := t.TempDir()
	gomod := "module testproject\ngo 1.21\n"
	os.WriteFile(filepath.Join(dir, "go.mod"), []byte(gomod), 0644)

	src := `package main

type Handler struct {
	svc string
}

func NewHandler(s string) *Handler {
	return &Handler{svc: s}
}

func (h *Handler) DoWork() string {
	return h.svc
}

func main() {
	h := NewHandler("test")
	_ = h.DoWork()
}
`
	os.WriteFile(filepath.Join(dir, "main.go"), []byte(src), 0644)

	result, err := Compile(dir, []string{"./..."})
	if err != nil {
		t.Fatalf("Compile: %v", err)
	}

	// Find DoWork in raw CompileResult to verify param instrs
	for _, pkg := range result.Packages {
		for _, fn := range pkg.Functions {
			if fn.ShortName == "DoWork" && fn.IsMethod {
				t.Logf("DoWork found, blocks=%d", len(fn.Blocks))
				if len(fn.Blocks) > 0 {
					for i, instr := range fn.Blocks[0].Instructions {
						t.Logf("  raw block0[%d]: id=%d kind=%s name=%s", i, instr.ID, instr.Kind, instr.Name)
					}
				}
			}
		}
	}

	// Serialize to FlatBuffers and read back
	fbBytes := BuildFlatBuffers(result)
	t.Logf("FlatBuffers size: %d bytes", len(fbBytes))

	root := ir.GetRootAsAnalysisResult(fbBytes, 0)
	foundParameter := false
	for i := 0; i < root.PackagesLength(); i++ {
		var pkg ir.Package
		root.Packages(&pkg, i)
		for j := 0; j < pkg.FunctionsLength(); j++ {
			var fn ir.Function
			pkg.Functions(&fn, j)
			if fn.IsMethod() {
				t.Logf("FB Method: %s (name=%s)", string(fn.QualifiedName()), string(fn.Name()))
				for k := 0; k < fn.BlocksLength(); k++ {
					var block ir.BasicBlock
					fn.Blocks(&block, k)
					if block.Id() == 0 {
						t.Logf("  Block 0 has %d instructions", block.InstructionsLength())
						for l := 0; l < block.InstructionsLength(); l++ {
							var instr ir.Instruction
							block.Instructions(&instr, l)
							t.Logf("  FB block0[%d]: kind=%d (%s) result_var=%s", l, instr.Kind(), instr.Kind().String(), string(instr.ResultVar()))
							if instr.Kind() == 35 {
								foundParameter = true
							}
						}
					}
				}
			}
		}
	}
	if !foundParameter {
		t.Error("expected to find Parameter instruction (kind=35) in FlatBuffers output for DoWork method")
	}
}
