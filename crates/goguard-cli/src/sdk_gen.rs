//! Python SDK code generation from MCP tool schemas.

use goguard_mcp::GoGuardMcpServer;

/// Generate Python SDK code for all GoGuard tools.
/// Returns the generated Python source as a String.
pub fn generate_python_sdk() -> String {
    let server = GoGuardMcpServer::new();
    let tools = server.tool_router_for_test().list_all();

    let mut out = String::new();

    // Header
    out.push_str("\"\"\"GoGuard Python SDK â€” auto-generated from tool schemas.\n\n");
    out.push_str("Generated by: goguard sdk generate python\n");
    out.push_str("Do not edit manually.\n");
    out.push_str("\"\"\"\n\n");
    out.push_str("from __future__ import annotations\n\n");
    out.push_str("import json\n");
    out.push_str("import subprocess\n");
    out.push_str("from pathlib import Path\n");
    out.push_str("from typing import Optional\n\n");
    out.push_str("from pydantic import BaseModel, Field\n");
    out.push_str("from enum import Enum\n\n\n");

    // Severity enum
    out.push_str("class Severity(str, Enum):\n");
    out.push_str("    critical = \"critical\"\n");
    out.push_str("    error = \"error\"\n");
    out.push_str("    warning = \"warning\"\n");
    out.push_str("    info = \"info\"\n\n\n");

    // Generate param classes from tool schemas
    for tool in &tools {
        let name = tool.name.as_ref();
        let class_name = to_pascal_case(name) + "Params";
        out.push_str(&format!("class {class_name}(BaseModel):\n"));
        out.push_str(&format!("    \"\"\"Parameters for {name}.\"\"\"\n"));

        // input_schema is Arc<serde_json::Map<String, Value>>
        let schema = &*tool.input_schema;
        if let Some(serde_json::Value::Object(props)) = schema.get("properties") {
            if props.is_empty() {
                out.push_str("    pass\n");
            } else {
                let required_fields: Vec<&str> = schema
                    .get("required")
                    .and_then(|r| r.as_array())
                    .map(|arr| arr.iter().filter_map(|v| v.as_str()).collect())
                    .unwrap_or_default();

                for (field_name, field_schema) in props {
                    let py_type = json_type_to_python(field_schema);
                    let is_required = required_fields.contains(&field_name.as_str());

                    if is_required {
                        out.push_str(&format!("    {field_name}: {py_type}\n"));
                    } else {
                        let default = python_default(&py_type);
                        out.push_str(&format!("    {field_name}: {py_type} = {default}\n"));
                    }
                }
            }
        } else {
            out.push_str("    pass\n");
        }
        out.push_str("\n\n");
    }

    // GoGuardError
    out.push_str("class GoGuardError(Exception):\n");
    out.push_str("    pass\n\n\n");

    // GoGuard class
    out.push_str("class GoGuard:\n");
    out.push_str("    \"\"\"GoGuard SDK client. Wraps the goguard CLI binary.\"\"\"\n\n");
    out.push_str("    def __init__(self, project_dir: str = \".\", binary: str = \"goguard\"):\n");
    out.push_str("        self.project_dir = str(Path(project_dir).resolve())\n");
    out.push_str("        self.binary = binary\n\n");
    out.push_str("    def _call(self, tool: str, params: Optional[dict] = None) -> dict:\n");
    out.push_str("        params = params or {}\n");
    out.push_str("        cmd = [\n");
    out.push_str("            self.binary, \"sdk\", \"call\", tool,\n");
    out.push_str("            \"--params\", json.dumps(params),\n");
    out.push_str("            \"--project-dir\", self.project_dir,\n");
    out.push_str("        ]\n");
    out.push_str(
        "        result = subprocess.run(cmd, capture_output=True, text=True, timeout=120)\n",
    );
    out.push_str("        if result.returncode != 0:\n");
    out.push_str("            raise GoGuardError(f\"goguard failed (exit {result.returncode}): {result.stderr}\")\n");
    out.push_str("        try:\n");
    out.push_str("            return json.loads(result.stdout)\n");
    out.push_str("        except json.JSONDecodeError:\n");
    out.push_str("            raise GoGuardError(f\"Invalid JSON: {result.stdout[:200]}\")\n\n");

    // Generate methods for each tool
    for tool in &tools {
        let name = tool.name.as_ref();
        // Strip "goguard_" prefix for method name
        let method_name = name.strip_prefix("goguard_").unwrap_or(name);
        let description = tool.description.as_ref().map(|s| s.as_ref()).unwrap_or("");

        out.push_str(&format!("    def {method_name}(self, **kwargs) -> dict:\n"));
        out.push_str(&format!("        \"\"\"{description}\"\"\"\n"));
        out.push_str(&format!(
            "        return self._call(\"{method_name}\", kwargs)\n\n"
        ));
    }

    out
}

fn to_pascal_case(s: &str) -> String {
    s.split('_')
        .map(|word| {
            let mut chars = word.chars();
            match chars.next() {
                None => String::new(),
                Some(c) => c.to_uppercase().collect::<String>() + &chars.collect::<String>(),
            }
        })
        .collect()
}

fn json_type_to_python(schema: &serde_json::Value) -> String {
    match schema.get("type").and_then(|t| t.as_str()) {
        Some("string") => "str".to_string(),
        Some("integer") => "int".to_string(),
        Some("number") => "float".to_string(),
        Some("boolean") => "bool".to_string(),
        Some("array") => {
            let items_type = schema
                .get("items")
                .map(json_type_to_python)
                .unwrap_or_else(|| "dict".to_string());
            format!("list[{items_type}]")
        }
        Some("object") => "dict".to_string(),
        _ => "dict".to_string(),
    }
}

fn python_default(py_type: &str) -> String {
    match py_type {
        "str" => "\"\"".to_string(),
        "int" => "0".to_string(),
        "float" => "0.0".to_string(),
        "bool" => "False".to_string(),
        t if t.starts_with("list") => "Field(default_factory=list)".to_string(),
        "dict" => "Field(default_factory=dict)".to_string(),
        _ => "None".to_string(),
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_sdk_generate_python_output() {
        let output = generate_python_sdk();
        assert!(output.contains("class GoGuard:"));
        assert!(output.contains("def analyze"));
        assert!(output.contains("def fix"));
    }

    #[test]
    fn test_sdk_generate_includes_all_tools() {
        let output = generate_python_sdk();
        assert!(output.contains("def analyze"), "missing analyze method");
        assert!(output.contains("def explain"), "missing explain method");
        assert!(output.contains("def fix"), "missing fix method");
        assert!(output.contains("def verify"), "missing verify method");
        assert!(output.contains("def rules"), "missing rules method");
        assert!(output.contains("def batch"), "missing batch method");
        assert!(output.contains("def snapshot"), "missing snapshot method");
        assert!(output.contains("def query"), "missing query method");
        assert!(output.contains("def search"), "missing search method");
        assert!(output.contains("def execute"), "missing execute method");
        assert!(output.contains("def autofix"), "missing autofix method");
    }

    #[test]
    fn test_sdk_generate_has_pydantic_models() {
        let output = generate_python_sdk();
        assert!(output.contains("BaseModel"));
        assert!(output.contains("Params(BaseModel)"));
    }

    #[test]
    fn test_sdk_generate_has_header() {
        let output = generate_python_sdk();
        assert!(output.contains("auto-generated from tool schemas"));
        assert!(output.contains("goguard sdk generate python"));
    }

    #[test]
    fn test_sdk_generate_has_severity_enum() {
        let output = generate_python_sdk();
        assert!(output.contains("class Severity(str, Enum):"));
        assert!(output.contains("critical = \"critical\""));
    }

    #[test]
    fn test_sdk_generate_has_error_class() {
        let output = generate_python_sdk();
        assert!(output.contains("class GoGuardError(Exception):"));
    }

    #[test]
    fn test_sdk_generate_uses_sdk_call_command() {
        let output = generate_python_sdk();
        assert!(output.contains("\"sdk\", \"call\""));
    }

    #[test]
    fn test_to_pascal_case() {
        assert_eq!(to_pascal_case("goguard_analyze"), "GoguardAnalyze");
        assert_eq!(to_pascal_case("goguard_fix"), "GoguardFix");
        assert_eq!(to_pascal_case("hello_world"), "HelloWorld");
        assert_eq!(to_pascal_case("single"), "Single");
    }

    #[test]
    fn test_json_type_to_python() {
        let string_schema = serde_json::json!({"type": "string"});
        assert_eq!(json_type_to_python(&string_schema), "str");

        let int_schema = serde_json::json!({"type": "integer"});
        assert_eq!(json_type_to_python(&int_schema), "int");

        let bool_schema = serde_json::json!({"type": "boolean"});
        assert_eq!(json_type_to_python(&bool_schema), "bool");

        let array_schema = serde_json::json!({"type": "array", "items": {"type": "string"}});
        assert_eq!(json_type_to_python(&array_schema), "list[str]");

        let obj_schema = serde_json::json!({"type": "object"});
        assert_eq!(json_type_to_python(&obj_schema), "dict");

        let unknown_schema = serde_json::json!({});
        assert_eq!(json_type_to_python(&unknown_schema), "dict");
    }

    #[test]
    fn test_python_default() {
        assert_eq!(python_default("str"), "\"\"");
        assert_eq!(python_default("int"), "0");
        assert_eq!(python_default("float"), "0.0");
        assert_eq!(python_default("bool"), "False");
        assert_eq!(python_default("list[str]"), "Field(default_factory=list)");
        assert_eq!(python_default("dict"), "Field(default_factory=dict)");
    }
}
