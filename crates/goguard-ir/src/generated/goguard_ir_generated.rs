// automatically generated by the FlatBuffers compiler, do not modify
// @generated
extern crate alloc;

#[allow(unused_imports, dead_code)]
pub mod goguard {

    #[allow(unused_imports, dead_code)]
    pub mod ir {

        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MIN_TYPE_KIND: i8 = 0;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MAX_TYPE_KIND: i8 = 11;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        #[allow(non_camel_case_types)]
        pub const ENUM_VALUES_TYPE_KIND: [TypeKind; 12] = [
            TypeKind::Basic,
            TypeKind::Pointer,
            TypeKind::Slice,
            TypeKind::Map,
            TypeKind::Channel,
            TypeKind::Struct,
            TypeKind::Interface,
            TypeKind::Function,
            TypeKind::Array,
            TypeKind::Named,
            TypeKind::Tuple,
            TypeKind::Nil,
        ];

        #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
        #[repr(transparent)]
        pub struct TypeKind(pub i8);
        #[allow(non_upper_case_globals)]
        impl TypeKind {
            pub const Basic: Self = Self(0);
            pub const Pointer: Self = Self(1);
            pub const Slice: Self = Self(2);
            pub const Map: Self = Self(3);
            pub const Channel: Self = Self(4);
            pub const Struct: Self = Self(5);
            pub const Interface: Self = Self(6);
            pub const Function: Self = Self(7);
            pub const Array: Self = Self(8);
            pub const Named: Self = Self(9);
            pub const Tuple: Self = Self(10);
            pub const Nil: Self = Self(11);

            pub const ENUM_MIN: i8 = 0;
            pub const ENUM_MAX: i8 = 11;
            pub const ENUM_VALUES: &'static [Self] = &[
                Self::Basic,
                Self::Pointer,
                Self::Slice,
                Self::Map,
                Self::Channel,
                Self::Struct,
                Self::Interface,
                Self::Function,
                Self::Array,
                Self::Named,
                Self::Tuple,
                Self::Nil,
            ];
            /// Returns the variant's name or "" if unknown.
            pub fn variant_name(self) -> Option<&'static str> {
                match self {
                    Self::Basic => Some("Basic"),
                    Self::Pointer => Some("Pointer"),
                    Self::Slice => Some("Slice"),
                    Self::Map => Some("Map"),
                    Self::Channel => Some("Channel"),
                    Self::Struct => Some("Struct"),
                    Self::Interface => Some("Interface"),
                    Self::Function => Some("Function"),
                    Self::Array => Some("Array"),
                    Self::Named => Some("Named"),
                    Self::Tuple => Some("Tuple"),
                    Self::Nil => Some("Nil"),
                    _ => None,
                }
            }
        }
        impl ::core::fmt::Debug for TypeKind {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                if let Some(name) = self.variant_name() {
                    f.write_str(name)
                } else {
                    f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
                }
            }
        }
        impl<'a> ::flatbuffers::Follow<'a> for TypeKind {
            type Inner = Self;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                let b = unsafe { ::flatbuffers::read_scalar_at::<i8>(buf, loc) };
                Self(b)
            }
        }

        impl ::flatbuffers::Push for TypeKind {
            type Output = TypeKind;
            #[inline]
            unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
                unsafe { ::flatbuffers::emplace_scalar::<i8>(dst, self.0) };
            }
        }

        impl ::flatbuffers::EndianScalar for TypeKind {
            type Scalar = i8;
            #[inline]
            fn to_little_endian(self) -> i8 {
                self.0.to_le()
            }
            #[inline]
            #[allow(clippy::wrong_self_convention)]
            fn from_little_endian(v: i8) -> Self {
                let b = i8::from_le(v);
                Self(b)
            }
        }

        impl<'a> ::flatbuffers::Verifiable for TypeKind {
            #[inline]
            fn run_verifier(
                v: &mut ::flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
                i8::run_verifier(v, pos)
            }
        }

        impl ::flatbuffers::SimpleToVerifyInSlice for TypeKind {}
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MIN_CHANNEL_DIR: i8 = 0;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MAX_CHANNEL_DIR: i8 = 2;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        #[allow(non_camel_case_types)]
        pub const ENUM_VALUES_CHANNEL_DIR: [ChannelDir; 3] = [
            ChannelDir::SendRecv,
            ChannelDir::SendOnly,
            ChannelDir::RecvOnly,
        ];

        #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
        #[repr(transparent)]
        pub struct ChannelDir(pub i8);
        #[allow(non_upper_case_globals)]
        impl ChannelDir {
            pub const SendRecv: Self = Self(0);
            pub const SendOnly: Self = Self(1);
            pub const RecvOnly: Self = Self(2);

            pub const ENUM_MIN: i8 = 0;
            pub const ENUM_MAX: i8 = 2;
            pub const ENUM_VALUES: &'static [Self] =
                &[Self::SendRecv, Self::SendOnly, Self::RecvOnly];
            /// Returns the variant's name or "" if unknown.
            pub fn variant_name(self) -> Option<&'static str> {
                match self {
                    Self::SendRecv => Some("SendRecv"),
                    Self::SendOnly => Some("SendOnly"),
                    Self::RecvOnly => Some("RecvOnly"),
                    _ => None,
                }
            }
        }
        impl ::core::fmt::Debug for ChannelDir {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                if let Some(name) = self.variant_name() {
                    f.write_str(name)
                } else {
                    f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
                }
            }
        }
        impl<'a> ::flatbuffers::Follow<'a> for ChannelDir {
            type Inner = Self;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                let b = unsafe { ::flatbuffers::read_scalar_at::<i8>(buf, loc) };
                Self(b)
            }
        }

        impl ::flatbuffers::Push for ChannelDir {
            type Output = ChannelDir;
            #[inline]
            unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
                unsafe { ::flatbuffers::emplace_scalar::<i8>(dst, self.0) };
            }
        }

        impl ::flatbuffers::EndianScalar for ChannelDir {
            type Scalar = i8;
            #[inline]
            fn to_little_endian(self) -> i8 {
                self.0.to_le()
            }
            #[inline]
            #[allow(clippy::wrong_self_convention)]
            fn from_little_endian(v: i8) -> Self {
                let b = i8::from_le(v);
                Self(b)
            }
        }

        impl<'a> ::flatbuffers::Verifiable for ChannelDir {
            #[inline]
            fn run_verifier(
                v: &mut ::flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
                i8::run_verifier(v, pos)
            }
        }

        impl ::flatbuffers::SimpleToVerifyInSlice for ChannelDir {}
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MIN_INSTRUCTION_KIND: i8 = 0;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MAX_INSTRUCTION_KIND: i8 = 35;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        #[allow(non_camel_case_types)]
        pub const ENUM_VALUES_INSTRUCTION_KIND: [InstructionKind; 36] = [
            InstructionKind::Alloc,
            InstructionKind::Phi,
            InstructionKind::Call,
            InstructionKind::BinOp,
            InstructionKind::UnOp,
            InstructionKind::Convert,
            InstructionKind::ChangeType,
            InstructionKind::MakeInterface,
            InstructionKind::MakeSlice,
            InstructionKind::MakeMap,
            InstructionKind::MakeChan,
            InstructionKind::MakeClosure,
            InstructionKind::FieldAddr,
            InstructionKind::IndexAddr,
            InstructionKind::Lookup,
            InstructionKind::MapLookup,
            InstructionKind::Slice,
            InstructionKind::If,
            InstructionKind::Jump,
            InstructionKind::Return,
            InstructionKind::Panic,
            InstructionKind::Go,
            InstructionKind::Defer,
            InstructionKind::Select,
            InstructionKind::Send,
            InstructionKind::TypeAssert,
            InstructionKind::ChangeInterface,
            InstructionKind::Extract,
            InstructionKind::Next,
            InstructionKind::Range,
            InstructionKind::Store,
            InstructionKind::Load,
            InstructionKind::MapUpdate,
            InstructionKind::RunDefers,
            InstructionKind::Unknown,
            InstructionKind::FuncParam,
        ];

        #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
        #[repr(transparent)]
        pub struct InstructionKind(pub i8);
        #[allow(non_upper_case_globals)]
        impl InstructionKind {
            pub const Alloc: Self = Self(0);
            pub const Phi: Self = Self(1);
            pub const Call: Self = Self(2);
            pub const BinOp: Self = Self(3);
            pub const UnOp: Self = Self(4);
            pub const Convert: Self = Self(5);
            pub const ChangeType: Self = Self(6);
            pub const MakeInterface: Self = Self(7);
            pub const MakeSlice: Self = Self(8);
            pub const MakeMap: Self = Self(9);
            pub const MakeChan: Self = Self(10);
            pub const MakeClosure: Self = Self(11);
            pub const FieldAddr: Self = Self(12);
            pub const IndexAddr: Self = Self(13);
            pub const Lookup: Self = Self(14);
            pub const MapLookup: Self = Self(15);
            pub const Slice: Self = Self(16);
            pub const If: Self = Self(17);
            pub const Jump: Self = Self(18);
            pub const Return: Self = Self(19);
            pub const Panic: Self = Self(20);
            pub const Go: Self = Self(21);
            pub const Defer: Self = Self(22);
            pub const Select: Self = Self(23);
            pub const Send: Self = Self(24);
            pub const TypeAssert: Self = Self(25);
            pub const ChangeInterface: Self = Self(26);
            pub const Extract: Self = Self(27);
            pub const Next: Self = Self(28);
            pub const Range: Self = Self(29);
            pub const Store: Self = Self(30);
            pub const Load: Self = Self(31);
            pub const MapUpdate: Self = Self(32);
            pub const RunDefers: Self = Self(33);
            pub const Unknown: Self = Self(34);
            pub const FuncParam: Self = Self(35);

            pub const ENUM_MIN: i8 = 0;
            pub const ENUM_MAX: i8 = 35;
            pub const ENUM_VALUES: &'static [Self] = &[
                Self::Alloc,
                Self::Phi,
                Self::Call,
                Self::BinOp,
                Self::UnOp,
                Self::Convert,
                Self::ChangeType,
                Self::MakeInterface,
                Self::MakeSlice,
                Self::MakeMap,
                Self::MakeChan,
                Self::MakeClosure,
                Self::FieldAddr,
                Self::IndexAddr,
                Self::Lookup,
                Self::MapLookup,
                Self::Slice,
                Self::If,
                Self::Jump,
                Self::Return,
                Self::Panic,
                Self::Go,
                Self::Defer,
                Self::Select,
                Self::Send,
                Self::TypeAssert,
                Self::ChangeInterface,
                Self::Extract,
                Self::Next,
                Self::Range,
                Self::Store,
                Self::Load,
                Self::MapUpdate,
                Self::RunDefers,
                Self::Unknown,
                Self::FuncParam,
            ];
            /// Returns the variant's name or "" if unknown.
            pub fn variant_name(self) -> Option<&'static str> {
                match self {
                    Self::Alloc => Some("Alloc"),
                    Self::Phi => Some("Phi"),
                    Self::Call => Some("Call"),
                    Self::BinOp => Some("BinOp"),
                    Self::UnOp => Some("UnOp"),
                    Self::Convert => Some("Convert"),
                    Self::ChangeType => Some("ChangeType"),
                    Self::MakeInterface => Some("MakeInterface"),
                    Self::MakeSlice => Some("MakeSlice"),
                    Self::MakeMap => Some("MakeMap"),
                    Self::MakeChan => Some("MakeChan"),
                    Self::MakeClosure => Some("MakeClosure"),
                    Self::FieldAddr => Some("FieldAddr"),
                    Self::IndexAddr => Some("IndexAddr"),
                    Self::Lookup => Some("Lookup"),
                    Self::MapLookup => Some("MapLookup"),
                    Self::Slice => Some("Slice"),
                    Self::If => Some("If"),
                    Self::Jump => Some("Jump"),
                    Self::Return => Some("Return"),
                    Self::Panic => Some("Panic"),
                    Self::Go => Some("Go"),
                    Self::Defer => Some("Defer"),
                    Self::Select => Some("Select"),
                    Self::Send => Some("Send"),
                    Self::TypeAssert => Some("TypeAssert"),
                    Self::ChangeInterface => Some("ChangeInterface"),
                    Self::Extract => Some("Extract"),
                    Self::Next => Some("Next"),
                    Self::Range => Some("Range"),
                    Self::Store => Some("Store"),
                    Self::Load => Some("Load"),
                    Self::MapUpdate => Some("MapUpdate"),
                    Self::RunDefers => Some("RunDefers"),
                    Self::Unknown => Some("Unknown"),
                    Self::FuncParam => Some("FuncParam"),
                    _ => None,
                }
            }
        }
        impl ::core::fmt::Debug for InstructionKind {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                if let Some(name) = self.variant_name() {
                    f.write_str(name)
                } else {
                    f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
                }
            }
        }
        impl<'a> ::flatbuffers::Follow<'a> for InstructionKind {
            type Inner = Self;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                let b = unsafe { ::flatbuffers::read_scalar_at::<i8>(buf, loc) };
                Self(b)
            }
        }

        impl ::flatbuffers::Push for InstructionKind {
            type Output = InstructionKind;
            #[inline]
            unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
                unsafe { ::flatbuffers::emplace_scalar::<i8>(dst, self.0) };
            }
        }

        impl ::flatbuffers::EndianScalar for InstructionKind {
            type Scalar = i8;
            #[inline]
            fn to_little_endian(self) -> i8 {
                self.0.to_le()
            }
            #[inline]
            #[allow(clippy::wrong_self_convention)]
            fn from_little_endian(v: i8) -> Self {
                let b = i8::from_le(v);
                Self(b)
            }
        }

        impl<'a> ::flatbuffers::Verifiable for InstructionKind {
            #[inline]
            fn run_verifier(
                v: &mut ::flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
                i8::run_verifier(v, pos)
            }
        }

        impl ::flatbuffers::SimpleToVerifyInSlice for InstructionKind {}
        pub enum SourcePosOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct SourcePos<'a> {
            pub _tab: ::flatbuffers::Table<'a>,
        }

        impl<'a> ::flatbuffers::Follow<'a> for SourcePos<'a> {
            type Inner = SourcePos<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: unsafe { ::flatbuffers::Table::new(buf, loc) },
                }
            }
        }

        impl<'a> SourcePos<'a> {
            pub const VT_FILE: ::flatbuffers::VOffsetT = 4;
            pub const VT_LINE: ::flatbuffers::VOffsetT = 6;
            pub const VT_COLUMN: ::flatbuffers::VOffsetT = 8;
            pub const VT_END_LINE: ::flatbuffers::VOffsetT = 10;
            pub const VT_END_COLUMN: ::flatbuffers::VOffsetT = 12;
            pub const VT_OFFSET: ::flatbuffers::VOffsetT = 14;

            #[inline]
            pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
                SourcePos { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: ::flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args SourcePosArgs<'args>,
            ) -> ::flatbuffers::WIPOffset<SourcePos<'bldr>> {
                let mut builder = SourcePosBuilder::new(_fbb);
                builder.add_offset(args.offset);
                builder.add_end_column(args.end_column);
                builder.add_end_line(args.end_line);
                builder.add_column(args.column);
                builder.add_line(args.line);
                if let Some(x) = args.file {
                    builder.add_file(x);
                }
                builder.finish()
            }

            #[inline]
            pub fn file(&self) -> Option<&'a str> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<::flatbuffers::ForwardsUOffset<&str>>(SourcePos::VT_FILE, None)
                }
            }
            #[inline]
            pub fn line(&self) -> i32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe { self._tab.get::<i32>(SourcePos::VT_LINE, Some(0)).unwrap() }
            }
            #[inline]
            pub fn column(&self) -> i32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe { self._tab.get::<i32>(SourcePos::VT_COLUMN, Some(0)).unwrap() }
            }
            #[inline]
            pub fn end_line(&self) -> i32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i32>(SourcePos::VT_END_LINE, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn end_column(&self) -> i32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i32>(SourcePos::VT_END_COLUMN, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn offset(&self) -> i32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe { self._tab.get::<i32>(SourcePos::VT_OFFSET, Some(0)).unwrap() }
            }
        }

        impl ::flatbuffers::Verifiable for SourcePos<'_> {
            #[inline]
            fn run_verifier(
                v: &mut ::flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
                v.visit_table(pos)?
                    .visit_field::<::flatbuffers::ForwardsUOffset<&str>>(
                        "file",
                        Self::VT_FILE,
                        false,
                    )?
                    .visit_field::<i32>("line", Self::VT_LINE, false)?
                    .visit_field::<i32>("column", Self::VT_COLUMN, false)?
                    .visit_field::<i32>("end_line", Self::VT_END_LINE, false)?
                    .visit_field::<i32>("end_column", Self::VT_END_COLUMN, false)?
                    .visit_field::<i32>("offset", Self::VT_OFFSET, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct SourcePosArgs<'a> {
            pub file: Option<::flatbuffers::WIPOffset<&'a str>>,
            pub line: i32,
            pub column: i32,
            pub end_line: i32,
            pub end_column: i32,
            pub offset: i32,
        }
        impl<'a> Default for SourcePosArgs<'a> {
            #[inline]
            fn default() -> Self {
                SourcePosArgs {
                    file: None,
                    line: 0,
                    column: 0,
                    end_line: 0,
                    end_column: 0,
                    offset: 0,
                }
            }
        }

        pub struct SourcePosBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
            fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> SourcePosBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_file(&mut self, file: ::flatbuffers::WIPOffset<&'b str>) {
                self.fbb_
                    .push_slot_always::<::flatbuffers::WIPOffset<_>>(SourcePos::VT_FILE, file);
            }
            #[inline]
            pub fn add_line(&mut self, line: i32) {
                self.fbb_.push_slot::<i32>(SourcePos::VT_LINE, line, 0);
            }
            #[inline]
            pub fn add_column(&mut self, column: i32) {
                self.fbb_.push_slot::<i32>(SourcePos::VT_COLUMN, column, 0);
            }
            #[inline]
            pub fn add_end_line(&mut self, end_line: i32) {
                self.fbb_
                    .push_slot::<i32>(SourcePos::VT_END_LINE, end_line, 0);
            }
            #[inline]
            pub fn add_end_column(&mut self, end_column: i32) {
                self.fbb_
                    .push_slot::<i32>(SourcePos::VT_END_COLUMN, end_column, 0);
            }
            #[inline]
            pub fn add_offset(&mut self, offset: i32) {
                self.fbb_.push_slot::<i32>(SourcePos::VT_OFFSET, offset, 0);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> SourcePosBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                SourcePosBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> ::flatbuffers::WIPOffset<SourcePos<'a>> {
                let o = self.fbb_.end_table(self.start_);
                ::flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl ::core::fmt::Debug for SourcePos<'_> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut ds = f.debug_struct("SourcePos");
                ds.field("file", &self.file());
                ds.field("line", &self.line());
                ds.field("column", &self.column());
                ds.field("end_line", &self.end_line());
                ds.field("end_column", &self.end_column());
                ds.field("offset", &self.offset());
                ds.finish()
            }
        }
        pub enum BridgeErrorOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct BridgeError<'a> {
            pub _tab: ::flatbuffers::Table<'a>,
        }

        impl<'a> ::flatbuffers::Follow<'a> for BridgeError<'a> {
            type Inner = BridgeError<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: unsafe { ::flatbuffers::Table::new(buf, loc) },
                }
            }
        }

        impl<'a> BridgeError<'a> {
            pub const VT_FILE: ::flatbuffers::VOffsetT = 4;
            pub const VT_LINE: ::flatbuffers::VOffsetT = 6;
            pub const VT_MESSAGE: ::flatbuffers::VOffsetT = 8;
            pub const VT_IS_TYPE_ERROR: ::flatbuffers::VOffsetT = 10;

            #[inline]
            pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
                BridgeError { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: ::flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args BridgeErrorArgs<'args>,
            ) -> ::flatbuffers::WIPOffset<BridgeError<'bldr>> {
                let mut builder = BridgeErrorBuilder::new(_fbb);
                if let Some(x) = args.message {
                    builder.add_message(x);
                }
                builder.add_line(args.line);
                if let Some(x) = args.file {
                    builder.add_file(x);
                }
                builder.add_is_type_error(args.is_type_error);
                builder.finish()
            }

            #[inline]
            pub fn file(&self) -> Option<&'a str> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<::flatbuffers::ForwardsUOffset<&str>>(BridgeError::VT_FILE, None)
                }
            }
            #[inline]
            pub fn line(&self) -> i32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe { self._tab.get::<i32>(BridgeError::VT_LINE, Some(0)).unwrap() }
            }
            #[inline]
            pub fn message(&self) -> Option<&'a str> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<::flatbuffers::ForwardsUOffset<&str>>(BridgeError::VT_MESSAGE, None)
                }
            }
            #[inline]
            pub fn is_type_error(&self) -> bool {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<bool>(BridgeError::VT_IS_TYPE_ERROR, Some(false))
                        .unwrap()
                }
            }
        }

        impl ::flatbuffers::Verifiable for BridgeError<'_> {
            #[inline]
            fn run_verifier(
                v: &mut ::flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
                v.visit_table(pos)?
                    .visit_field::<::flatbuffers::ForwardsUOffset<&str>>(
                        "file",
                        Self::VT_FILE,
                        false,
                    )?
                    .visit_field::<i32>("line", Self::VT_LINE, false)?
                    .visit_field::<::flatbuffers::ForwardsUOffset<&str>>(
                        "message",
                        Self::VT_MESSAGE,
                        false,
                    )?
                    .visit_field::<bool>("is_type_error", Self::VT_IS_TYPE_ERROR, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct BridgeErrorArgs<'a> {
            pub file: Option<::flatbuffers::WIPOffset<&'a str>>,
            pub line: i32,
            pub message: Option<::flatbuffers::WIPOffset<&'a str>>,
            pub is_type_error: bool,
        }
        impl<'a> Default for BridgeErrorArgs<'a> {
            #[inline]
            fn default() -> Self {
                BridgeErrorArgs {
                    file: None,
                    line: 0,
                    message: None,
                    is_type_error: false,
                }
            }
        }

        pub struct BridgeErrorBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
            fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> BridgeErrorBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_file(&mut self, file: ::flatbuffers::WIPOffset<&'b str>) {
                self.fbb_
                    .push_slot_always::<::flatbuffers::WIPOffset<_>>(BridgeError::VT_FILE, file);
            }
            #[inline]
            pub fn add_line(&mut self, line: i32) {
                self.fbb_.push_slot::<i32>(BridgeError::VT_LINE, line, 0);
            }
            #[inline]
            pub fn add_message(&mut self, message: ::flatbuffers::WIPOffset<&'b str>) {
                self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(
                    BridgeError::VT_MESSAGE,
                    message,
                );
            }
            #[inline]
            pub fn add_is_type_error(&mut self, is_type_error: bool) {
                self.fbb_
                    .push_slot::<bool>(BridgeError::VT_IS_TYPE_ERROR, is_type_error, false);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> BridgeErrorBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                BridgeErrorBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> ::flatbuffers::WIPOffset<BridgeError<'a>> {
                let o = self.fbb_.end_table(self.start_);
                ::flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl ::core::fmt::Debug for BridgeError<'_> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut ds = f.debug_struct("BridgeError");
                ds.field("file", &self.file());
                ds.field("line", &self.line());
                ds.field("message", &self.message());
                ds.field("is_type_error", &self.is_type_error());
                ds.finish()
            }
        }
        pub enum DeferInfoOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct DeferInfo<'a> {
            pub _tab: ::flatbuffers::Table<'a>,
        }

        impl<'a> ::flatbuffers::Follow<'a> for DeferInfo<'a> {
            type Inner = DeferInfo<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: unsafe { ::flatbuffers::Table::new(buf, loc) },
                }
            }
        }

        impl<'a> DeferInfo<'a> {
            pub const VT_CALL_TARGET: ::flatbuffers::VOffsetT = 4;
            pub const VT_SOURCE_POS: ::flatbuffers::VOffsetT = 6;
            pub const VT_INDEX: ::flatbuffers::VOffsetT = 8;

            #[inline]
            pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
                DeferInfo { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: ::flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args DeferInfoArgs<'args>,
            ) -> ::flatbuffers::WIPOffset<DeferInfo<'bldr>> {
                let mut builder = DeferInfoBuilder::new(_fbb);
                builder.add_index(args.index);
                if let Some(x) = args.source_pos {
                    builder.add_source_pos(x);
                }
                if let Some(x) = args.call_target {
                    builder.add_call_target(x);
                }
                builder.finish()
            }

            #[inline]
            pub fn call_target(&self) -> Option<&'a str> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(
                        DeferInfo::VT_CALL_TARGET,
                        None,
                    )
                }
            }
            #[inline]
            pub fn source_pos(&self) -> Option<SourcePos<'a>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<::flatbuffers::ForwardsUOffset<SourcePos>>(
                        DeferInfo::VT_SOURCE_POS,
                        None,
                    )
                }
            }
            #[inline]
            pub fn index(&self) -> i32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe { self._tab.get::<i32>(DeferInfo::VT_INDEX, Some(0)).unwrap() }
            }
        }

        impl ::flatbuffers::Verifiable for DeferInfo<'_> {
            #[inline]
            fn run_verifier(
                v: &mut ::flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
                v.visit_table(pos)?
                    .visit_field::<::flatbuffers::ForwardsUOffset<&str>>(
                        "call_target",
                        Self::VT_CALL_TARGET,
                        false,
                    )?
                    .visit_field::<::flatbuffers::ForwardsUOffset<SourcePos>>(
                        "source_pos",
                        Self::VT_SOURCE_POS,
                        false,
                    )?
                    .visit_field::<i32>("index", Self::VT_INDEX, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct DeferInfoArgs<'a> {
            pub call_target: Option<::flatbuffers::WIPOffset<&'a str>>,
            pub source_pos: Option<::flatbuffers::WIPOffset<SourcePos<'a>>>,
            pub index: i32,
        }
        impl<'a> Default for DeferInfoArgs<'a> {
            #[inline]
            fn default() -> Self {
                DeferInfoArgs {
                    call_target: None,
                    source_pos: None,
                    index: 0,
                }
            }
        }

        pub struct DeferInfoBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
            fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> DeferInfoBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_call_target(&mut self, call_target: ::flatbuffers::WIPOffset<&'b str>) {
                self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(
                    DeferInfo::VT_CALL_TARGET,
                    call_target,
                );
            }
            #[inline]
            pub fn add_source_pos(&mut self, source_pos: ::flatbuffers::WIPOffset<SourcePos<'b>>) {
                self.fbb_
                    .push_slot_always::<::flatbuffers::WIPOffset<SourcePos>>(
                        DeferInfo::VT_SOURCE_POS,
                        source_pos,
                    );
            }
            #[inline]
            pub fn add_index(&mut self, index: i32) {
                self.fbb_.push_slot::<i32>(DeferInfo::VT_INDEX, index, 0);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> DeferInfoBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                DeferInfoBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> ::flatbuffers::WIPOffset<DeferInfo<'a>> {
                let o = self.fbb_.end_table(self.start_);
                ::flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl ::core::fmt::Debug for DeferInfo<'_> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut ds = f.debug_struct("DeferInfo");
                ds.field("call_target", &self.call_target());
                ds.field("source_pos", &self.source_pos());
                ds.field("index", &self.index());
                ds.finish()
            }
        }
        pub enum TypeInfoOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct TypeInfo<'a> {
            pub _tab: ::flatbuffers::Table<'a>,
        }

        impl<'a> ::flatbuffers::Follow<'a> for TypeInfo<'a> {
            type Inner = TypeInfo<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: unsafe { ::flatbuffers::Table::new(buf, loc) },
                }
            }
        }

        impl<'a> TypeInfo<'a> {
            pub const VT_KIND: ::flatbuffers::VOffsetT = 4;
            pub const VT_NAME: ::flatbuffers::VOffsetT = 6;
            pub const VT_UNDERLYING: ::flatbuffers::VOffsetT = 8;
            pub const VT_IS_POINTER: ::flatbuffers::VOffsetT = 10;
            pub const VT_IS_INTERFACE: ::flatbuffers::VOffsetT = 12;
            pub const VT_IS_ERROR: ::flatbuffers::VOffsetT = 14;
            pub const VT_IS_CHANNEL: ::flatbuffers::VOffsetT = 16;
            pub const VT_CHANNEL_DIR: ::flatbuffers::VOffsetT = 18;
            pub const VT_ELEM_TYPE: ::flatbuffers::VOffsetT = 20;
            pub const VT_KEY_TYPE: ::flatbuffers::VOffsetT = 22;

            #[inline]
            pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
                TypeInfo { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: ::flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args TypeInfoArgs<'args>,
            ) -> ::flatbuffers::WIPOffset<TypeInfo<'bldr>> {
                let mut builder = TypeInfoBuilder::new(_fbb);
                if let Some(x) = args.key_type {
                    builder.add_key_type(x);
                }
                if let Some(x) = args.elem_type {
                    builder.add_elem_type(x);
                }
                if let Some(x) = args.underlying {
                    builder.add_underlying(x);
                }
                if let Some(x) = args.name {
                    builder.add_name(x);
                }
                builder.add_channel_dir(args.channel_dir);
                builder.add_is_channel(args.is_channel);
                builder.add_is_error(args.is_error);
                builder.add_is_interface(args.is_interface);
                builder.add_is_pointer(args.is_pointer);
                builder.add_kind(args.kind);
                builder.finish()
            }

            #[inline]
            pub fn kind(&self) -> TypeKind {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<TypeKind>(TypeInfo::VT_KIND, Some(TypeKind::Basic))
                        .unwrap()
                }
            }
            #[inline]
            pub fn name(&self) -> Option<&'a str> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<::flatbuffers::ForwardsUOffset<&str>>(TypeInfo::VT_NAME, None)
                }
            }
            #[inline]
            pub fn underlying(&self) -> Option<&'a str> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<::flatbuffers::ForwardsUOffset<&str>>(TypeInfo::VT_UNDERLYING, None)
                }
            }
            #[inline]
            pub fn is_pointer(&self) -> bool {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<bool>(TypeInfo::VT_IS_POINTER, Some(false))
                        .unwrap()
                }
            }
            #[inline]
            pub fn is_interface(&self) -> bool {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<bool>(TypeInfo::VT_IS_INTERFACE, Some(false))
                        .unwrap()
                }
            }
            #[inline]
            pub fn is_error(&self) -> bool {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<bool>(TypeInfo::VT_IS_ERROR, Some(false))
                        .unwrap()
                }
            }
            #[inline]
            pub fn is_channel(&self) -> bool {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<bool>(TypeInfo::VT_IS_CHANNEL, Some(false))
                        .unwrap()
                }
            }
            #[inline]
            pub fn channel_dir(&self) -> ChannelDir {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<ChannelDir>(TypeInfo::VT_CHANNEL_DIR, Some(ChannelDir::SendRecv))
                        .unwrap()
                }
            }
            #[inline]
            pub fn elem_type(&self) -> Option<&'a str> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<::flatbuffers::ForwardsUOffset<&str>>(TypeInfo::VT_ELEM_TYPE, None)
                }
            }
            #[inline]
            pub fn key_type(&self) -> Option<&'a str> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<::flatbuffers::ForwardsUOffset<&str>>(TypeInfo::VT_KEY_TYPE, None)
                }
            }
        }

        impl ::flatbuffers::Verifiable for TypeInfo<'_> {
            #[inline]
            fn run_verifier(
                v: &mut ::flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
                v.visit_table(pos)?
                    .visit_field::<TypeKind>("kind", Self::VT_KIND, false)?
                    .visit_field::<::flatbuffers::ForwardsUOffset<&str>>(
                        "name",
                        Self::VT_NAME,
                        false,
                    )?
                    .visit_field::<::flatbuffers::ForwardsUOffset<&str>>(
                        "underlying",
                        Self::VT_UNDERLYING,
                        false,
                    )?
                    .visit_field::<bool>("is_pointer", Self::VT_IS_POINTER, false)?
                    .visit_field::<bool>("is_interface", Self::VT_IS_INTERFACE, false)?
                    .visit_field::<bool>("is_error", Self::VT_IS_ERROR, false)?
                    .visit_field::<bool>("is_channel", Self::VT_IS_CHANNEL, false)?
                    .visit_field::<ChannelDir>("channel_dir", Self::VT_CHANNEL_DIR, false)?
                    .visit_field::<::flatbuffers::ForwardsUOffset<&str>>(
                        "elem_type",
                        Self::VT_ELEM_TYPE,
                        false,
                    )?
                    .visit_field::<::flatbuffers::ForwardsUOffset<&str>>(
                        "key_type",
                        Self::VT_KEY_TYPE,
                        false,
                    )?
                    .finish();
                Ok(())
            }
        }
        pub struct TypeInfoArgs<'a> {
            pub kind: TypeKind,
            pub name: Option<::flatbuffers::WIPOffset<&'a str>>,
            pub underlying: Option<::flatbuffers::WIPOffset<&'a str>>,
            pub is_pointer: bool,
            pub is_interface: bool,
            pub is_error: bool,
            pub is_channel: bool,
            pub channel_dir: ChannelDir,
            pub elem_type: Option<::flatbuffers::WIPOffset<&'a str>>,
            pub key_type: Option<::flatbuffers::WIPOffset<&'a str>>,
        }
        impl<'a> Default for TypeInfoArgs<'a> {
            #[inline]
            fn default() -> Self {
                TypeInfoArgs {
                    kind: TypeKind::Basic,
                    name: None,
                    underlying: None,
                    is_pointer: false,
                    is_interface: false,
                    is_error: false,
                    is_channel: false,
                    channel_dir: ChannelDir::SendRecv,
                    elem_type: None,
                    key_type: None,
                }
            }
        }

        pub struct TypeInfoBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
            fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> TypeInfoBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_kind(&mut self, kind: TypeKind) {
                self.fbb_
                    .push_slot::<TypeKind>(TypeInfo::VT_KIND, kind, TypeKind::Basic);
            }
            #[inline]
            pub fn add_name(&mut self, name: ::flatbuffers::WIPOffset<&'b str>) {
                self.fbb_
                    .push_slot_always::<::flatbuffers::WIPOffset<_>>(TypeInfo::VT_NAME, name);
            }
            #[inline]
            pub fn add_underlying(&mut self, underlying: ::flatbuffers::WIPOffset<&'b str>) {
                self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(
                    TypeInfo::VT_UNDERLYING,
                    underlying,
                );
            }
            #[inline]
            pub fn add_is_pointer(&mut self, is_pointer: bool) {
                self.fbb_
                    .push_slot::<bool>(TypeInfo::VT_IS_POINTER, is_pointer, false);
            }
            #[inline]
            pub fn add_is_interface(&mut self, is_interface: bool) {
                self.fbb_
                    .push_slot::<bool>(TypeInfo::VT_IS_INTERFACE, is_interface, false);
            }
            #[inline]
            pub fn add_is_error(&mut self, is_error: bool) {
                self.fbb_
                    .push_slot::<bool>(TypeInfo::VT_IS_ERROR, is_error, false);
            }
            #[inline]
            pub fn add_is_channel(&mut self, is_channel: bool) {
                self.fbb_
                    .push_slot::<bool>(TypeInfo::VT_IS_CHANNEL, is_channel, false);
            }
            #[inline]
            pub fn add_channel_dir(&mut self, channel_dir: ChannelDir) {
                self.fbb_.push_slot::<ChannelDir>(
                    TypeInfo::VT_CHANNEL_DIR,
                    channel_dir,
                    ChannelDir::SendRecv,
                );
            }
            #[inline]
            pub fn add_elem_type(&mut self, elem_type: ::flatbuffers::WIPOffset<&'b str>) {
                self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(
                    TypeInfo::VT_ELEM_TYPE,
                    elem_type,
                );
            }
            #[inline]
            pub fn add_key_type(&mut self, key_type: ::flatbuffers::WIPOffset<&'b str>) {
                self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(
                    TypeInfo::VT_KEY_TYPE,
                    key_type,
                );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> TypeInfoBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                TypeInfoBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> ::flatbuffers::WIPOffset<TypeInfo<'a>> {
                let o = self.fbb_.end_table(self.start_);
                ::flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl ::core::fmt::Debug for TypeInfo<'_> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut ds = f.debug_struct("TypeInfo");
                ds.field("kind", &self.kind());
                ds.field("name", &self.name());
                ds.field("underlying", &self.underlying());
                ds.field("is_pointer", &self.is_pointer());
                ds.field("is_interface", &self.is_interface());
                ds.field("is_error", &self.is_error());
                ds.field("is_channel", &self.is_channel());
                ds.field("channel_dir", &self.channel_dir());
                ds.field("elem_type", &self.elem_type());
                ds.field("key_type", &self.key_type());
                ds.finish()
            }
        }
        pub enum VariableOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct Variable<'a> {
            pub _tab: ::flatbuffers::Table<'a>,
        }

        impl<'a> ::flatbuffers::Follow<'a> for Variable<'a> {
            type Inner = Variable<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: unsafe { ::flatbuffers::Table::new(buf, loc) },
                }
            }
        }

        impl<'a> Variable<'a> {
            pub const VT_NAME: ::flatbuffers::VOffsetT = 4;
            pub const VT_TYPE_INFO: ::flatbuffers::VOffsetT = 6;
            pub const VT_SOURCE_POS: ::flatbuffers::VOffsetT = 8;

            #[inline]
            pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
                Variable { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: ::flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args VariableArgs<'args>,
            ) -> ::flatbuffers::WIPOffset<Variable<'bldr>> {
                let mut builder = VariableBuilder::new(_fbb);
                if let Some(x) = args.source_pos {
                    builder.add_source_pos(x);
                }
                if let Some(x) = args.type_info {
                    builder.add_type_info(x);
                }
                if let Some(x) = args.name {
                    builder.add_name(x);
                }
                builder.finish()
            }

            #[inline]
            pub fn name(&self) -> Option<&'a str> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<::flatbuffers::ForwardsUOffset<&str>>(Variable::VT_NAME, None)
                }
            }
            #[inline]
            pub fn type_info(&self) -> Option<TypeInfo<'a>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<::flatbuffers::ForwardsUOffset<TypeInfo>>(
                        Variable::VT_TYPE_INFO,
                        None,
                    )
                }
            }
            #[inline]
            pub fn source_pos(&self) -> Option<SourcePos<'a>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<::flatbuffers::ForwardsUOffset<SourcePos>>(
                        Variable::VT_SOURCE_POS,
                        None,
                    )
                }
            }
        }

        impl ::flatbuffers::Verifiable for Variable<'_> {
            #[inline]
            fn run_verifier(
                v: &mut ::flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
                v.visit_table(pos)?
                    .visit_field::<::flatbuffers::ForwardsUOffset<&str>>(
                        "name",
                        Self::VT_NAME,
                        false,
                    )?
                    .visit_field::<::flatbuffers::ForwardsUOffset<TypeInfo>>(
                        "type_info",
                        Self::VT_TYPE_INFO,
                        false,
                    )?
                    .visit_field::<::flatbuffers::ForwardsUOffset<SourcePos>>(
                        "source_pos",
                        Self::VT_SOURCE_POS,
                        false,
                    )?
                    .finish();
                Ok(())
            }
        }
        pub struct VariableArgs<'a> {
            pub name: Option<::flatbuffers::WIPOffset<&'a str>>,
            pub type_info: Option<::flatbuffers::WIPOffset<TypeInfo<'a>>>,
            pub source_pos: Option<::flatbuffers::WIPOffset<SourcePos<'a>>>,
        }
        impl<'a> Default for VariableArgs<'a> {
            #[inline]
            fn default() -> Self {
                VariableArgs {
                    name: None,
                    type_info: None,
                    source_pos: None,
                }
            }
        }

        pub struct VariableBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
            fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> VariableBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_name(&mut self, name: ::flatbuffers::WIPOffset<&'b str>) {
                self.fbb_
                    .push_slot_always::<::flatbuffers::WIPOffset<_>>(Variable::VT_NAME, name);
            }
            #[inline]
            pub fn add_type_info(&mut self, type_info: ::flatbuffers::WIPOffset<TypeInfo<'b>>) {
                self.fbb_
                    .push_slot_always::<::flatbuffers::WIPOffset<TypeInfo>>(
                        Variable::VT_TYPE_INFO,
                        type_info,
                    );
            }
            #[inline]
            pub fn add_source_pos(&mut self, source_pos: ::flatbuffers::WIPOffset<SourcePos<'b>>) {
                self.fbb_
                    .push_slot_always::<::flatbuffers::WIPOffset<SourcePos>>(
                        Variable::VT_SOURCE_POS,
                        source_pos,
                    );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> VariableBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                VariableBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> ::flatbuffers::WIPOffset<Variable<'a>> {
                let o = self.fbb_.end_table(self.start_);
                ::flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl ::core::fmt::Debug for Variable<'_> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut ds = f.debug_struct("Variable");
                ds.field("name", &self.name());
                ds.field("type_info", &self.type_info());
                ds.field("source_pos", &self.source_pos());
                ds.finish()
            }
        }
        pub enum SelectCaseOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct SelectCase<'a> {
            pub _tab: ::flatbuffers::Table<'a>,
        }

        impl<'a> ::flatbuffers::Follow<'a> for SelectCase<'a> {
            type Inner = SelectCase<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: unsafe { ::flatbuffers::Table::new(buf, loc) },
                }
            }
        }

        impl<'a> SelectCase<'a> {
            pub const VT_DIR: ::flatbuffers::VOffsetT = 4;
            pub const VT_CHANNEL: ::flatbuffers::VOffsetT = 6;
            pub const VT_IS_DEFAULT: ::flatbuffers::VOffsetT = 8;

            #[inline]
            pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
                SelectCase { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: ::flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args SelectCaseArgs<'args>,
            ) -> ::flatbuffers::WIPOffset<SelectCase<'bldr>> {
                let mut builder = SelectCaseBuilder::new(_fbb);
                if let Some(x) = args.channel {
                    builder.add_channel(x);
                }
                builder.add_is_default(args.is_default);
                builder.add_dir(args.dir);
                builder.finish()
            }

            #[inline]
            pub fn dir(&self) -> ChannelDir {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<ChannelDir>(SelectCase::VT_DIR, Some(ChannelDir::SendRecv))
                        .unwrap()
                }
            }
            #[inline]
            pub fn channel(&self) -> Option<&'a str> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<::flatbuffers::ForwardsUOffset<&str>>(SelectCase::VT_CHANNEL, None)
                }
            }
            #[inline]
            pub fn is_default(&self) -> bool {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<bool>(SelectCase::VT_IS_DEFAULT, Some(false))
                        .unwrap()
                }
            }
        }

        impl ::flatbuffers::Verifiable for SelectCase<'_> {
            #[inline]
            fn run_verifier(
                v: &mut ::flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
                v.visit_table(pos)?
                    .visit_field::<ChannelDir>("dir", Self::VT_DIR, false)?
                    .visit_field::<::flatbuffers::ForwardsUOffset<&str>>(
                        "channel",
                        Self::VT_CHANNEL,
                        false,
                    )?
                    .visit_field::<bool>("is_default", Self::VT_IS_DEFAULT, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct SelectCaseArgs<'a> {
            pub dir: ChannelDir,
            pub channel: Option<::flatbuffers::WIPOffset<&'a str>>,
            pub is_default: bool,
        }
        impl<'a> Default for SelectCaseArgs<'a> {
            #[inline]
            fn default() -> Self {
                SelectCaseArgs {
                    dir: ChannelDir::SendRecv,
                    channel: None,
                    is_default: false,
                }
            }
        }

        pub struct SelectCaseBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
            fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> SelectCaseBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_dir(&mut self, dir: ChannelDir) {
                self.fbb_
                    .push_slot::<ChannelDir>(SelectCase::VT_DIR, dir, ChannelDir::SendRecv);
            }
            #[inline]
            pub fn add_channel(&mut self, channel: ::flatbuffers::WIPOffset<&'b str>) {
                self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(
                    SelectCase::VT_CHANNEL,
                    channel,
                );
            }
            #[inline]
            pub fn add_is_default(&mut self, is_default: bool) {
                self.fbb_
                    .push_slot::<bool>(SelectCase::VT_IS_DEFAULT, is_default, false);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> SelectCaseBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                SelectCaseBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> ::flatbuffers::WIPOffset<SelectCase<'a>> {
                let o = self.fbb_.end_table(self.start_);
                ::flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl ::core::fmt::Debug for SelectCase<'_> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut ds = f.debug_struct("SelectCase");
                ds.field("dir", &self.dir());
                ds.field("channel", &self.channel());
                ds.field("is_default", &self.is_default());
                ds.finish()
            }
        }
        pub enum OperandOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct Operand<'a> {
            pub _tab: ::flatbuffers::Table<'a>,
        }

        impl<'a> ::flatbuffers::Follow<'a> for Operand<'a> {
            type Inner = Operand<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: unsafe { ::flatbuffers::Table::new(buf, loc) },
                }
            }
        }

        impl<'a> Operand<'a> {
            pub const VT_NAME: ::flatbuffers::VOffsetT = 4;
            pub const VT_TYPE_INFO: ::flatbuffers::VOffsetT = 6;
            pub const VT_IS_CONSTANT: ::flatbuffers::VOffsetT = 8;
            pub const VT_CONSTANT_VALUE: ::flatbuffers::VOffsetT = 10;
            pub const VT_IS_NIL: ::flatbuffers::VOffsetT = 12;

            #[inline]
            pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
                Operand { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: ::flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args OperandArgs<'args>,
            ) -> ::flatbuffers::WIPOffset<Operand<'bldr>> {
                let mut builder = OperandBuilder::new(_fbb);
                if let Some(x) = args.constant_value {
                    builder.add_constant_value(x);
                }
                if let Some(x) = args.type_info {
                    builder.add_type_info(x);
                }
                if let Some(x) = args.name {
                    builder.add_name(x);
                }
                builder.add_is_nil(args.is_nil);
                builder.add_is_constant(args.is_constant);
                builder.finish()
            }

            #[inline]
            pub fn name(&self) -> Option<&'a str> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<::flatbuffers::ForwardsUOffset<&str>>(Operand::VT_NAME, None)
                }
            }
            #[inline]
            pub fn type_info(&self) -> Option<TypeInfo<'a>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<::flatbuffers::ForwardsUOffset<TypeInfo>>(
                        Operand::VT_TYPE_INFO,
                        None,
                    )
                }
            }
            #[inline]
            pub fn is_constant(&self) -> bool {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<bool>(Operand::VT_IS_CONSTANT, Some(false))
                        .unwrap()
                }
            }
            #[inline]
            pub fn constant_value(&self) -> Option<&'a str> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(
                        Operand::VT_CONSTANT_VALUE,
                        None,
                    )
                }
            }
            #[inline]
            pub fn is_nil(&self) -> bool {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<bool>(Operand::VT_IS_NIL, Some(false))
                        .unwrap()
                }
            }
        }

        impl ::flatbuffers::Verifiable for Operand<'_> {
            #[inline]
            fn run_verifier(
                v: &mut ::flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
                v.visit_table(pos)?
                    .visit_field::<::flatbuffers::ForwardsUOffset<&str>>(
                        "name",
                        Self::VT_NAME,
                        false,
                    )?
                    .visit_field::<::flatbuffers::ForwardsUOffset<TypeInfo>>(
                        "type_info",
                        Self::VT_TYPE_INFO,
                        false,
                    )?
                    .visit_field::<bool>("is_constant", Self::VT_IS_CONSTANT, false)?
                    .visit_field::<::flatbuffers::ForwardsUOffset<&str>>(
                        "constant_value",
                        Self::VT_CONSTANT_VALUE,
                        false,
                    )?
                    .visit_field::<bool>("is_nil", Self::VT_IS_NIL, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct OperandArgs<'a> {
            pub name: Option<::flatbuffers::WIPOffset<&'a str>>,
            pub type_info: Option<::flatbuffers::WIPOffset<TypeInfo<'a>>>,
            pub is_constant: bool,
            pub constant_value: Option<::flatbuffers::WIPOffset<&'a str>>,
            pub is_nil: bool,
        }
        impl<'a> Default for OperandArgs<'a> {
            #[inline]
            fn default() -> Self {
                OperandArgs {
                    name: None,
                    type_info: None,
                    is_constant: false,
                    constant_value: None,
                    is_nil: false,
                }
            }
        }

        pub struct OperandBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
            fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> OperandBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_name(&mut self, name: ::flatbuffers::WIPOffset<&'b str>) {
                self.fbb_
                    .push_slot_always::<::flatbuffers::WIPOffset<_>>(Operand::VT_NAME, name);
            }
            #[inline]
            pub fn add_type_info(&mut self, type_info: ::flatbuffers::WIPOffset<TypeInfo<'b>>) {
                self.fbb_
                    .push_slot_always::<::flatbuffers::WIPOffset<TypeInfo>>(
                        Operand::VT_TYPE_INFO,
                        type_info,
                    );
            }
            #[inline]
            pub fn add_is_constant(&mut self, is_constant: bool) {
                self.fbb_
                    .push_slot::<bool>(Operand::VT_IS_CONSTANT, is_constant, false);
            }
            #[inline]
            pub fn add_constant_value(
                &mut self,
                constant_value: ::flatbuffers::WIPOffset<&'b str>,
            ) {
                self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(
                    Operand::VT_CONSTANT_VALUE,
                    constant_value,
                );
            }
            #[inline]
            pub fn add_is_nil(&mut self, is_nil: bool) {
                self.fbb_
                    .push_slot::<bool>(Operand::VT_IS_NIL, is_nil, false);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> OperandBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                OperandBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> ::flatbuffers::WIPOffset<Operand<'a>> {
                let o = self.fbb_.end_table(self.start_);
                ::flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl ::core::fmt::Debug for Operand<'_> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut ds = f.debug_struct("Operand");
                ds.field("name", &self.name());
                ds.field("type_info", &self.type_info());
                ds.field("is_constant", &self.is_constant());
                ds.field("constant_value", &self.constant_value());
                ds.field("is_nil", &self.is_nil());
                ds.finish()
            }
        }
        pub enum InstructionOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct Instruction<'a> {
            pub _tab: ::flatbuffers::Table<'a>,
        }

        impl<'a> ::flatbuffers::Follow<'a> for Instruction<'a> {
            type Inner = Instruction<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: unsafe { ::flatbuffers::Table::new(buf, loc) },
                }
            }
        }

        impl<'a> Instruction<'a> {
            pub const VT_KIND: ::flatbuffers::VOffsetT = 4;
            pub const VT_SOURCE_POS: ::flatbuffers::VOffsetT = 6;
            pub const VT_RESULT_VAR: ::flatbuffers::VOffsetT = 8;
            pub const VT_RESULT_TYPE: ::flatbuffers::VOffsetT = 10;
            pub const VT_OPERANDS: ::flatbuffers::VOffsetT = 12;
            pub const VT_CALL_TARGET: ::flatbuffers::VOffsetT = 14;
            pub const VT_CALL_TARGET_QUALIFIED: ::flatbuffers::VOffsetT = 16;
            pub const VT_IS_INTERFACE_CALL: ::flatbuffers::VOffsetT = 18;
            pub const VT_FIELD_NAME: ::flatbuffers::VOffsetT = 20;
            pub const VT_MAP_KEY: ::flatbuffers::VOffsetT = 22;
            pub const VT_CHANNEL_OP: ::flatbuffers::VOffsetT = 24;
            pub const VT_TYPE_ASSERT_TARGET: ::flatbuffers::VOffsetT = 26;
            pub const VT_TYPE_ASSERT_HAS_OK: ::flatbuffers::VOffsetT = 28;
            pub const VT_SELECT_CASES: ::flatbuffers::VOffsetT = 30;
            pub const VT_EXTRACT_INDEX: ::flatbuffers::VOffsetT = 32;

            #[inline]
            pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
                Instruction { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: ::flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args InstructionArgs<'args>,
            ) -> ::flatbuffers::WIPOffset<Instruction<'bldr>> {
                let mut builder = InstructionBuilder::new(_fbb);
                builder.add_extract_index(args.extract_index);
                if let Some(x) = args.select_cases {
                    builder.add_select_cases(x);
                }
                if let Some(x) = args.type_assert_target {
                    builder.add_type_assert_target(x);
                }
                if let Some(x) = args.map_key {
                    builder.add_map_key(x);
                }
                if let Some(x) = args.field_name {
                    builder.add_field_name(x);
                }
                if let Some(x) = args.call_target_qualified {
                    builder.add_call_target_qualified(x);
                }
                if let Some(x) = args.call_target {
                    builder.add_call_target(x);
                }
                if let Some(x) = args.operands {
                    builder.add_operands(x);
                }
                if let Some(x) = args.result_type {
                    builder.add_result_type(x);
                }
                if let Some(x) = args.result_var {
                    builder.add_result_var(x);
                }
                if let Some(x) = args.source_pos {
                    builder.add_source_pos(x);
                }
                builder.add_type_assert_has_ok(args.type_assert_has_ok);
                builder.add_channel_op(args.channel_op);
                builder.add_is_interface_call(args.is_interface_call);
                builder.add_kind(args.kind);
                builder.finish()
            }

            #[inline]
            pub fn kind(&self) -> InstructionKind {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<InstructionKind>(Instruction::VT_KIND, Some(InstructionKind::Alloc))
                        .unwrap()
                }
            }
            #[inline]
            pub fn source_pos(&self) -> Option<SourcePos<'a>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<::flatbuffers::ForwardsUOffset<SourcePos>>(
                        Instruction::VT_SOURCE_POS,
                        None,
                    )
                }
            }
            #[inline]
            pub fn result_var(&self) -> Option<&'a str> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(
                        Instruction::VT_RESULT_VAR,
                        None,
                    )
                }
            }
            #[inline]
            pub fn result_type(&self) -> Option<TypeInfo<'a>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<::flatbuffers::ForwardsUOffset<TypeInfo>>(
                        Instruction::VT_RESULT_TYPE,
                        None,
                    )
                }
            }
            #[inline]
            pub fn operands(
                &self,
            ) -> Option<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<Operand<'a>>>>
            {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<::flatbuffers::ForwardsUOffset<
                        ::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<Operand>>,
                    >>(Instruction::VT_OPERANDS, None)
                }
            }
            #[inline]
            pub fn call_target(&self) -> Option<&'a str> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(
                        Instruction::VT_CALL_TARGET,
                        None,
                    )
                }
            }
            #[inline]
            pub fn call_target_qualified(&self) -> Option<&'a str> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(
                        Instruction::VT_CALL_TARGET_QUALIFIED,
                        None,
                    )
                }
            }
            #[inline]
            pub fn is_interface_call(&self) -> bool {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<bool>(Instruction::VT_IS_INTERFACE_CALL, Some(false))
                        .unwrap()
                }
            }
            #[inline]
            pub fn field_name(&self) -> Option<&'a str> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(
                        Instruction::VT_FIELD_NAME,
                        None,
                    )
                }
            }
            #[inline]
            pub fn map_key(&self) -> Option<&'a str> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<::flatbuffers::ForwardsUOffset<&str>>(Instruction::VT_MAP_KEY, None)
                }
            }
            #[inline]
            pub fn channel_op(&self) -> ChannelDir {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<ChannelDir>(Instruction::VT_CHANNEL_OP, Some(ChannelDir::SendRecv))
                        .unwrap()
                }
            }
            #[inline]
            pub fn type_assert_target(&self) -> Option<&'a str> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(
                        Instruction::VT_TYPE_ASSERT_TARGET,
                        None,
                    )
                }
            }
            #[inline]
            pub fn type_assert_has_ok(&self) -> bool {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<bool>(Instruction::VT_TYPE_ASSERT_HAS_OK, Some(false))
                        .unwrap()
                }
            }
            #[inline]
            pub fn select_cases(
                &self,
            ) -> Option<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<SelectCase<'a>>>>
            {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<::flatbuffers::ForwardsUOffset<
                        ::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<SelectCase>>,
                    >>(Instruction::VT_SELECT_CASES, None)
                }
            }
            #[inline]
            pub fn extract_index(&self) -> i32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i32>(Instruction::VT_EXTRACT_INDEX, Some(0))
                        .unwrap()
                }
            }
        }

        impl ::flatbuffers::Verifiable for Instruction<'_> {
            #[inline]
            fn run_verifier(
                v: &mut ::flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
                v.visit_table(pos)?
                    .visit_field::<InstructionKind>("kind", Self::VT_KIND, false)?
                    .visit_field::<::flatbuffers::ForwardsUOffset<SourcePos>>(
                        "source_pos",
                        Self::VT_SOURCE_POS,
                        false,
                    )?
                    .visit_field::<::flatbuffers::ForwardsUOffset<&str>>(
                        "result_var",
                        Self::VT_RESULT_VAR,
                        false,
                    )?
                    .visit_field::<::flatbuffers::ForwardsUOffset<TypeInfo>>(
                        "result_type",
                        Self::VT_RESULT_TYPE,
                        false,
                    )?
                    .visit_field::<::flatbuffers::ForwardsUOffset<
                        ::flatbuffers::Vector<'_, ::flatbuffers::ForwardsUOffset<Operand>>,
                    >>("operands", Self::VT_OPERANDS, false)?
                    .visit_field::<::flatbuffers::ForwardsUOffset<&str>>(
                        "call_target",
                        Self::VT_CALL_TARGET,
                        false,
                    )?
                    .visit_field::<::flatbuffers::ForwardsUOffset<&str>>(
                        "call_target_qualified",
                        Self::VT_CALL_TARGET_QUALIFIED,
                        false,
                    )?
                    .visit_field::<bool>("is_interface_call", Self::VT_IS_INTERFACE_CALL, false)?
                    .visit_field::<::flatbuffers::ForwardsUOffset<&str>>(
                        "field_name",
                        Self::VT_FIELD_NAME,
                        false,
                    )?
                    .visit_field::<::flatbuffers::ForwardsUOffset<&str>>(
                        "map_key",
                        Self::VT_MAP_KEY,
                        false,
                    )?
                    .visit_field::<ChannelDir>("channel_op", Self::VT_CHANNEL_OP, false)?
                    .visit_field::<::flatbuffers::ForwardsUOffset<&str>>(
                        "type_assert_target",
                        Self::VT_TYPE_ASSERT_TARGET,
                        false,
                    )?
                    .visit_field::<bool>("type_assert_has_ok", Self::VT_TYPE_ASSERT_HAS_OK, false)?
                    .visit_field::<::flatbuffers::ForwardsUOffset<
                        ::flatbuffers::Vector<'_, ::flatbuffers::ForwardsUOffset<SelectCase>>,
                    >>("select_cases", Self::VT_SELECT_CASES, false)?
                    .visit_field::<i32>("extract_index", Self::VT_EXTRACT_INDEX, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct InstructionArgs<'a> {
            pub kind: InstructionKind,
            pub source_pos: Option<::flatbuffers::WIPOffset<SourcePos<'a>>>,
            pub result_var: Option<::flatbuffers::WIPOffset<&'a str>>,
            pub result_type: Option<::flatbuffers::WIPOffset<TypeInfo<'a>>>,
            pub operands: Option<
                ::flatbuffers::WIPOffset<
                    ::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<Operand<'a>>>,
                >,
            >,
            pub call_target: Option<::flatbuffers::WIPOffset<&'a str>>,
            pub call_target_qualified: Option<::flatbuffers::WIPOffset<&'a str>>,
            pub is_interface_call: bool,
            pub field_name: Option<::flatbuffers::WIPOffset<&'a str>>,
            pub map_key: Option<::flatbuffers::WIPOffset<&'a str>>,
            pub channel_op: ChannelDir,
            pub type_assert_target: Option<::flatbuffers::WIPOffset<&'a str>>,
            pub type_assert_has_ok: bool,
            pub select_cases: Option<
                ::flatbuffers::WIPOffset<
                    ::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<SelectCase<'a>>>,
                >,
            >,
            pub extract_index: i32,
        }
        impl<'a> Default for InstructionArgs<'a> {
            #[inline]
            fn default() -> Self {
                InstructionArgs {
                    kind: InstructionKind::Alloc,
                    source_pos: None,
                    result_var: None,
                    result_type: None,
                    operands: None,
                    call_target: None,
                    call_target_qualified: None,
                    is_interface_call: false,
                    field_name: None,
                    map_key: None,
                    channel_op: ChannelDir::SendRecv,
                    type_assert_target: None,
                    type_assert_has_ok: false,
                    select_cases: None,
                    extract_index: 0,
                }
            }
        }

        pub struct InstructionBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
            fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> InstructionBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_kind(&mut self, kind: InstructionKind) {
                self.fbb_.push_slot::<InstructionKind>(
                    Instruction::VT_KIND,
                    kind,
                    InstructionKind::Alloc,
                );
            }
            #[inline]
            pub fn add_source_pos(&mut self, source_pos: ::flatbuffers::WIPOffset<SourcePos<'b>>) {
                self.fbb_
                    .push_slot_always::<::flatbuffers::WIPOffset<SourcePos>>(
                        Instruction::VT_SOURCE_POS,
                        source_pos,
                    );
            }
            #[inline]
            pub fn add_result_var(&mut self, result_var: ::flatbuffers::WIPOffset<&'b str>) {
                self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(
                    Instruction::VT_RESULT_VAR,
                    result_var,
                );
            }
            #[inline]
            pub fn add_result_type(&mut self, result_type: ::flatbuffers::WIPOffset<TypeInfo<'b>>) {
                self.fbb_
                    .push_slot_always::<::flatbuffers::WIPOffset<TypeInfo>>(
                        Instruction::VT_RESULT_TYPE,
                        result_type,
                    );
            }
            #[inline]
            pub fn add_operands(
                &mut self,
                operands: ::flatbuffers::WIPOffset<
                    ::flatbuffers::Vector<'b, ::flatbuffers::ForwardsUOffset<Operand<'b>>>,
                >,
            ) {
                self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(
                    Instruction::VT_OPERANDS,
                    operands,
                );
            }
            #[inline]
            pub fn add_call_target(&mut self, call_target: ::flatbuffers::WIPOffset<&'b str>) {
                self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(
                    Instruction::VT_CALL_TARGET,
                    call_target,
                );
            }
            #[inline]
            pub fn add_call_target_qualified(
                &mut self,
                call_target_qualified: ::flatbuffers::WIPOffset<&'b str>,
            ) {
                self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(
                    Instruction::VT_CALL_TARGET_QUALIFIED,
                    call_target_qualified,
                );
            }
            #[inline]
            pub fn add_is_interface_call(&mut self, is_interface_call: bool) {
                self.fbb_.push_slot::<bool>(
                    Instruction::VT_IS_INTERFACE_CALL,
                    is_interface_call,
                    false,
                );
            }
            #[inline]
            pub fn add_field_name(&mut self, field_name: ::flatbuffers::WIPOffset<&'b str>) {
                self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(
                    Instruction::VT_FIELD_NAME,
                    field_name,
                );
            }
            #[inline]
            pub fn add_map_key(&mut self, map_key: ::flatbuffers::WIPOffset<&'b str>) {
                self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(
                    Instruction::VT_MAP_KEY,
                    map_key,
                );
            }
            #[inline]
            pub fn add_channel_op(&mut self, channel_op: ChannelDir) {
                self.fbb_.push_slot::<ChannelDir>(
                    Instruction::VT_CHANNEL_OP,
                    channel_op,
                    ChannelDir::SendRecv,
                );
            }
            #[inline]
            pub fn add_type_assert_target(
                &mut self,
                type_assert_target: ::flatbuffers::WIPOffset<&'b str>,
            ) {
                self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(
                    Instruction::VT_TYPE_ASSERT_TARGET,
                    type_assert_target,
                );
            }
            #[inline]
            pub fn add_type_assert_has_ok(&mut self, type_assert_has_ok: bool) {
                self.fbb_.push_slot::<bool>(
                    Instruction::VT_TYPE_ASSERT_HAS_OK,
                    type_assert_has_ok,
                    false,
                );
            }
            #[inline]
            pub fn add_select_cases(
                &mut self,
                select_cases: ::flatbuffers::WIPOffset<
                    ::flatbuffers::Vector<'b, ::flatbuffers::ForwardsUOffset<SelectCase<'b>>>,
                >,
            ) {
                self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(
                    Instruction::VT_SELECT_CASES,
                    select_cases,
                );
            }
            #[inline]
            pub fn add_extract_index(&mut self, extract_index: i32) {
                self.fbb_
                    .push_slot::<i32>(Instruction::VT_EXTRACT_INDEX, extract_index, 0);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> InstructionBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                InstructionBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> ::flatbuffers::WIPOffset<Instruction<'a>> {
                let o = self.fbb_.end_table(self.start_);
                ::flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl ::core::fmt::Debug for Instruction<'_> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut ds = f.debug_struct("Instruction");
                ds.field("kind", &self.kind());
                ds.field("source_pos", &self.source_pos());
                ds.field("result_var", &self.result_var());
                ds.field("result_type", &self.result_type());
                ds.field("operands", &self.operands());
                ds.field("call_target", &self.call_target());
                ds.field("call_target_qualified", &self.call_target_qualified());
                ds.field("is_interface_call", &self.is_interface_call());
                ds.field("field_name", &self.field_name());
                ds.field("map_key", &self.map_key());
                ds.field("channel_op", &self.channel_op());
                ds.field("type_assert_target", &self.type_assert_target());
                ds.field("type_assert_has_ok", &self.type_assert_has_ok());
                ds.field("select_cases", &self.select_cases());
                ds.field("extract_index", &self.extract_index());
                ds.finish()
            }
        }
        pub enum BasicBlockOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct BasicBlock<'a> {
            pub _tab: ::flatbuffers::Table<'a>,
        }

        impl<'a> ::flatbuffers::Follow<'a> for BasicBlock<'a> {
            type Inner = BasicBlock<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: unsafe { ::flatbuffers::Table::new(buf, loc) },
                }
            }
        }

        impl<'a> BasicBlock<'a> {
            pub const VT_ID: ::flatbuffers::VOffsetT = 4;
            pub const VT_INSTRUCTIONS: ::flatbuffers::VOffsetT = 6;
            pub const VT_SUCCESSORS: ::flatbuffers::VOffsetT = 8;
            pub const VT_PREDECESSORS: ::flatbuffers::VOffsetT = 10;
            pub const VT_IS_ENTRY: ::flatbuffers::VOffsetT = 12;
            pub const VT_IS_EXIT: ::flatbuffers::VOffsetT = 14;
            pub const VT_IS_DEFER_BLOCK: ::flatbuffers::VOffsetT = 16;
            pub const VT_SOURCE_POS: ::flatbuffers::VOffsetT = 18;

            #[inline]
            pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
                BasicBlock { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: ::flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args BasicBlockArgs<'args>,
            ) -> ::flatbuffers::WIPOffset<BasicBlock<'bldr>> {
                let mut builder = BasicBlockBuilder::new(_fbb);
                if let Some(x) = args.source_pos {
                    builder.add_source_pos(x);
                }
                if let Some(x) = args.predecessors {
                    builder.add_predecessors(x);
                }
                if let Some(x) = args.successors {
                    builder.add_successors(x);
                }
                if let Some(x) = args.instructions {
                    builder.add_instructions(x);
                }
                builder.add_id(args.id);
                builder.add_is_defer_block(args.is_defer_block);
                builder.add_is_exit(args.is_exit);
                builder.add_is_entry(args.is_entry);
                builder.finish()
            }

            #[inline]
            pub fn id(&self) -> i32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe { self._tab.get::<i32>(BasicBlock::VT_ID, Some(0)).unwrap() }
            }
            #[inline]
            pub fn instructions(
                &self,
            ) -> Option<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<Instruction<'a>>>>
            {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<::flatbuffers::ForwardsUOffset<
                        ::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<Instruction>>,
                    >>(BasicBlock::VT_INSTRUCTIONS, None)
                }
            }
            #[inline]
            pub fn successors(&self) -> Option<::flatbuffers::Vector<'a, i32>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'a, i32>>>(
                            BasicBlock::VT_SUCCESSORS,
                            None,
                        )
                }
            }
            #[inline]
            pub fn predecessors(&self) -> Option<::flatbuffers::Vector<'a, i32>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'a, i32>>>(
                            BasicBlock::VT_PREDECESSORS,
                            None,
                        )
                }
            }
            #[inline]
            pub fn is_entry(&self) -> bool {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<bool>(BasicBlock::VT_IS_ENTRY, Some(false))
                        .unwrap()
                }
            }
            #[inline]
            pub fn is_exit(&self) -> bool {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<bool>(BasicBlock::VT_IS_EXIT, Some(false))
                        .unwrap()
                }
            }
            #[inline]
            pub fn is_defer_block(&self) -> bool {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<bool>(BasicBlock::VT_IS_DEFER_BLOCK, Some(false))
                        .unwrap()
                }
            }
            #[inline]
            pub fn source_pos(&self) -> Option<SourcePos<'a>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<::flatbuffers::ForwardsUOffset<SourcePos>>(
                        BasicBlock::VT_SOURCE_POS,
                        None,
                    )
                }
            }
        }

        impl ::flatbuffers::Verifiable for BasicBlock<'_> {
            #[inline]
            fn run_verifier(
                v: &mut ::flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
                v.visit_table(pos)?
                    .visit_field::<i32>("id", Self::VT_ID, false)?
                    .visit_field::<::flatbuffers::ForwardsUOffset<
                        ::flatbuffers::Vector<'_, ::flatbuffers::ForwardsUOffset<Instruction>>,
                    >>("instructions", Self::VT_INSTRUCTIONS, false)?
                    .visit_field::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'_, i32>>>(
                        "successors",
                        Self::VT_SUCCESSORS,
                        false,
                    )?
                    .visit_field::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'_, i32>>>(
                        "predecessors",
                        Self::VT_PREDECESSORS,
                        false,
                    )?
                    .visit_field::<bool>("is_entry", Self::VT_IS_ENTRY, false)?
                    .visit_field::<bool>("is_exit", Self::VT_IS_EXIT, false)?
                    .visit_field::<bool>("is_defer_block", Self::VT_IS_DEFER_BLOCK, false)?
                    .visit_field::<::flatbuffers::ForwardsUOffset<SourcePos>>(
                        "source_pos",
                        Self::VT_SOURCE_POS,
                        false,
                    )?
                    .finish();
                Ok(())
            }
        }
        pub struct BasicBlockArgs<'a> {
            pub id: i32,
            pub instructions: Option<
                ::flatbuffers::WIPOffset<
                    ::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<Instruction<'a>>>,
                >,
            >,
            pub successors: Option<::flatbuffers::WIPOffset<::flatbuffers::Vector<'a, i32>>>,
            pub predecessors: Option<::flatbuffers::WIPOffset<::flatbuffers::Vector<'a, i32>>>,
            pub is_entry: bool,
            pub is_exit: bool,
            pub is_defer_block: bool,
            pub source_pos: Option<::flatbuffers::WIPOffset<SourcePos<'a>>>,
        }
        impl<'a> Default for BasicBlockArgs<'a> {
            #[inline]
            fn default() -> Self {
                BasicBlockArgs {
                    id: 0,
                    instructions: None,
                    successors: None,
                    predecessors: None,
                    is_entry: false,
                    is_exit: false,
                    is_defer_block: false,
                    source_pos: None,
                }
            }
        }

        pub struct BasicBlockBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
            fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> BasicBlockBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_id(&mut self, id: i32) {
                self.fbb_.push_slot::<i32>(BasicBlock::VT_ID, id, 0);
            }
            #[inline]
            pub fn add_instructions(
                &mut self,
                instructions: ::flatbuffers::WIPOffset<
                    ::flatbuffers::Vector<'b, ::flatbuffers::ForwardsUOffset<Instruction<'b>>>,
                >,
            ) {
                self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(
                    BasicBlock::VT_INSTRUCTIONS,
                    instructions,
                );
            }
            #[inline]
            pub fn add_successors(
                &mut self,
                successors: ::flatbuffers::WIPOffset<::flatbuffers::Vector<'b, i32>>,
            ) {
                self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(
                    BasicBlock::VT_SUCCESSORS,
                    successors,
                );
            }
            #[inline]
            pub fn add_predecessors(
                &mut self,
                predecessors: ::flatbuffers::WIPOffset<::flatbuffers::Vector<'b, i32>>,
            ) {
                self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(
                    BasicBlock::VT_PREDECESSORS,
                    predecessors,
                );
            }
            #[inline]
            pub fn add_is_entry(&mut self, is_entry: bool) {
                self.fbb_
                    .push_slot::<bool>(BasicBlock::VT_IS_ENTRY, is_entry, false);
            }
            #[inline]
            pub fn add_is_exit(&mut self, is_exit: bool) {
                self.fbb_
                    .push_slot::<bool>(BasicBlock::VT_IS_EXIT, is_exit, false);
            }
            #[inline]
            pub fn add_is_defer_block(&mut self, is_defer_block: bool) {
                self.fbb_
                    .push_slot::<bool>(BasicBlock::VT_IS_DEFER_BLOCK, is_defer_block, false);
            }
            #[inline]
            pub fn add_source_pos(&mut self, source_pos: ::flatbuffers::WIPOffset<SourcePos<'b>>) {
                self.fbb_
                    .push_slot_always::<::flatbuffers::WIPOffset<SourcePos>>(
                        BasicBlock::VT_SOURCE_POS,
                        source_pos,
                    );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> BasicBlockBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                BasicBlockBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> ::flatbuffers::WIPOffset<BasicBlock<'a>> {
                let o = self.fbb_.end_table(self.start_);
                ::flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl ::core::fmt::Debug for BasicBlock<'_> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut ds = f.debug_struct("BasicBlock");
                ds.field("id", &self.id());
                ds.field("instructions", &self.instructions());
                ds.field("successors", &self.successors());
                ds.field("predecessors", &self.predecessors());
                ds.field("is_entry", &self.is_entry());
                ds.field("is_exit", &self.is_exit());
                ds.field("is_defer_block", &self.is_defer_block());
                ds.field("source_pos", &self.source_pos());
                ds.finish()
            }
        }
        pub enum ParameterOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct Parameter<'a> {
            pub _tab: ::flatbuffers::Table<'a>,
        }

        impl<'a> ::flatbuffers::Follow<'a> for Parameter<'a> {
            type Inner = Parameter<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: unsafe { ::flatbuffers::Table::new(buf, loc) },
                }
            }
        }

        impl<'a> Parameter<'a> {
            pub const VT_NAME: ::flatbuffers::VOffsetT = 4;
            pub const VT_TYPE_INFO: ::flatbuffers::VOffsetT = 6;

            #[inline]
            pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
                Parameter { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: ::flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args ParameterArgs<'args>,
            ) -> ::flatbuffers::WIPOffset<Parameter<'bldr>> {
                let mut builder = ParameterBuilder::new(_fbb);
                if let Some(x) = args.type_info {
                    builder.add_type_info(x);
                }
                if let Some(x) = args.name {
                    builder.add_name(x);
                }
                builder.finish()
            }

            #[inline]
            pub fn name(&self) -> Option<&'a str> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<::flatbuffers::ForwardsUOffset<&str>>(Parameter::VT_NAME, None)
                }
            }
            #[inline]
            pub fn type_info(&self) -> Option<TypeInfo<'a>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<::flatbuffers::ForwardsUOffset<TypeInfo>>(
                        Parameter::VT_TYPE_INFO,
                        None,
                    )
                }
            }
        }

        impl ::flatbuffers::Verifiable for Parameter<'_> {
            #[inline]
            fn run_verifier(
                v: &mut ::flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
                v.visit_table(pos)?
                    .visit_field::<::flatbuffers::ForwardsUOffset<&str>>(
                        "name",
                        Self::VT_NAME,
                        false,
                    )?
                    .visit_field::<::flatbuffers::ForwardsUOffset<TypeInfo>>(
                        "type_info",
                        Self::VT_TYPE_INFO,
                        false,
                    )?
                    .finish();
                Ok(())
            }
        }
        pub struct ParameterArgs<'a> {
            pub name: Option<::flatbuffers::WIPOffset<&'a str>>,
            pub type_info: Option<::flatbuffers::WIPOffset<TypeInfo<'a>>>,
        }
        impl<'a> Default for ParameterArgs<'a> {
            #[inline]
            fn default() -> Self {
                ParameterArgs {
                    name: None,
                    type_info: None,
                }
            }
        }

        pub struct ParameterBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
            fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> ParameterBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_name(&mut self, name: ::flatbuffers::WIPOffset<&'b str>) {
                self.fbb_
                    .push_slot_always::<::flatbuffers::WIPOffset<_>>(Parameter::VT_NAME, name);
            }
            #[inline]
            pub fn add_type_info(&mut self, type_info: ::flatbuffers::WIPOffset<TypeInfo<'b>>) {
                self.fbb_
                    .push_slot_always::<::flatbuffers::WIPOffset<TypeInfo>>(
                        Parameter::VT_TYPE_INFO,
                        type_info,
                    );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> ParameterBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                ParameterBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> ::flatbuffers::WIPOffset<Parameter<'a>> {
                let o = self.fbb_.end_table(self.start_);
                ::flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl ::core::fmt::Debug for Parameter<'_> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut ds = f.debug_struct("Parameter");
                ds.field("name", &self.name());
                ds.field("type_info", &self.type_info());
                ds.finish()
            }
        }
        pub enum ReturnTypeOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct ReturnType<'a> {
            pub _tab: ::flatbuffers::Table<'a>,
        }

        impl<'a> ::flatbuffers::Follow<'a> for ReturnType<'a> {
            type Inner = ReturnType<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: unsafe { ::flatbuffers::Table::new(buf, loc) },
                }
            }
        }

        impl<'a> ReturnType<'a> {
            pub const VT_NAME: ::flatbuffers::VOffsetT = 4;
            pub const VT_TYPE_INFO: ::flatbuffers::VOffsetT = 6;

            #[inline]
            pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
                ReturnType { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: ::flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args ReturnTypeArgs<'args>,
            ) -> ::flatbuffers::WIPOffset<ReturnType<'bldr>> {
                let mut builder = ReturnTypeBuilder::new(_fbb);
                if let Some(x) = args.type_info {
                    builder.add_type_info(x);
                }
                if let Some(x) = args.name {
                    builder.add_name(x);
                }
                builder.finish()
            }

            #[inline]
            pub fn name(&self) -> Option<&'a str> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<::flatbuffers::ForwardsUOffset<&str>>(ReturnType::VT_NAME, None)
                }
            }
            #[inline]
            pub fn type_info(&self) -> Option<TypeInfo<'a>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<::flatbuffers::ForwardsUOffset<TypeInfo>>(
                        ReturnType::VT_TYPE_INFO,
                        None,
                    )
                }
            }
        }

        impl ::flatbuffers::Verifiable for ReturnType<'_> {
            #[inline]
            fn run_verifier(
                v: &mut ::flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
                v.visit_table(pos)?
                    .visit_field::<::flatbuffers::ForwardsUOffset<&str>>(
                        "name",
                        Self::VT_NAME,
                        false,
                    )?
                    .visit_field::<::flatbuffers::ForwardsUOffset<TypeInfo>>(
                        "type_info",
                        Self::VT_TYPE_INFO,
                        false,
                    )?
                    .finish();
                Ok(())
            }
        }
        pub struct ReturnTypeArgs<'a> {
            pub name: Option<::flatbuffers::WIPOffset<&'a str>>,
            pub type_info: Option<::flatbuffers::WIPOffset<TypeInfo<'a>>>,
        }
        impl<'a> Default for ReturnTypeArgs<'a> {
            #[inline]
            fn default() -> Self {
                ReturnTypeArgs {
                    name: None,
                    type_info: None,
                }
            }
        }

        pub struct ReturnTypeBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
            fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> ReturnTypeBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_name(&mut self, name: ::flatbuffers::WIPOffset<&'b str>) {
                self.fbb_
                    .push_slot_always::<::flatbuffers::WIPOffset<_>>(ReturnType::VT_NAME, name);
            }
            #[inline]
            pub fn add_type_info(&mut self, type_info: ::flatbuffers::WIPOffset<TypeInfo<'b>>) {
                self.fbb_
                    .push_slot_always::<::flatbuffers::WIPOffset<TypeInfo>>(
                        ReturnType::VT_TYPE_INFO,
                        type_info,
                    );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> ReturnTypeBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                ReturnTypeBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> ::flatbuffers::WIPOffset<ReturnType<'a>> {
                let o = self.fbb_.end_table(self.start_);
                ::flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl ::core::fmt::Debug for ReturnType<'_> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut ds = f.debug_struct("ReturnType");
                ds.field("name", &self.name());
                ds.field("type_info", &self.type_info());
                ds.finish()
            }
        }
        pub enum FunctionSignatureOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct FunctionSignature<'a> {
            pub _tab: ::flatbuffers::Table<'a>,
        }

        impl<'a> ::flatbuffers::Follow<'a> for FunctionSignature<'a> {
            type Inner = FunctionSignature<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: unsafe { ::flatbuffers::Table::new(buf, loc) },
                }
            }
        }

        impl<'a> FunctionSignature<'a> {
            pub const VT_PARAMS: ::flatbuffers::VOffsetT = 4;
            pub const VT_RETURNS: ::flatbuffers::VOffsetT = 6;
            pub const VT_IS_VARIADIC: ::flatbuffers::VOffsetT = 8;

            #[inline]
            pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
                FunctionSignature { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: ::flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args FunctionSignatureArgs<'args>,
            ) -> ::flatbuffers::WIPOffset<FunctionSignature<'bldr>> {
                let mut builder = FunctionSignatureBuilder::new(_fbb);
                if let Some(x) = args.returns {
                    builder.add_returns(x);
                }
                if let Some(x) = args.params {
                    builder.add_params(x);
                }
                builder.add_is_variadic(args.is_variadic);
                builder.finish()
            }

            #[inline]
            pub fn params(
                &self,
            ) -> Option<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<Parameter<'a>>>>
            {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<::flatbuffers::ForwardsUOffset<
                        ::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<Parameter>>,
                    >>(FunctionSignature::VT_PARAMS, None)
                }
            }
            #[inline]
            pub fn returns(
                &self,
            ) -> Option<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<ReturnType<'a>>>>
            {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<::flatbuffers::ForwardsUOffset<
                        ::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<ReturnType>>,
                    >>(FunctionSignature::VT_RETURNS, None)
                }
            }
            #[inline]
            pub fn is_variadic(&self) -> bool {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<bool>(FunctionSignature::VT_IS_VARIADIC, Some(false))
                        .unwrap()
                }
            }
        }

        impl ::flatbuffers::Verifiable for FunctionSignature<'_> {
            #[inline]
            fn run_verifier(
                v: &mut ::flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
                v.visit_table(pos)?
                    .visit_field::<::flatbuffers::ForwardsUOffset<
                        ::flatbuffers::Vector<'_, ::flatbuffers::ForwardsUOffset<Parameter>>,
                    >>("params", Self::VT_PARAMS, false)?
                    .visit_field::<::flatbuffers::ForwardsUOffset<
                        ::flatbuffers::Vector<'_, ::flatbuffers::ForwardsUOffset<ReturnType>>,
                    >>("returns", Self::VT_RETURNS, false)?
                    .visit_field::<bool>("is_variadic", Self::VT_IS_VARIADIC, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct FunctionSignatureArgs<'a> {
            pub params: Option<
                ::flatbuffers::WIPOffset<
                    ::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<Parameter<'a>>>,
                >,
            >,
            pub returns: Option<
                ::flatbuffers::WIPOffset<
                    ::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<ReturnType<'a>>>,
                >,
            >,
            pub is_variadic: bool,
        }
        impl<'a> Default for FunctionSignatureArgs<'a> {
            #[inline]
            fn default() -> Self {
                FunctionSignatureArgs {
                    params: None,
                    returns: None,
                    is_variadic: false,
                }
            }
        }

        pub struct FunctionSignatureBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
            fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> FunctionSignatureBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_params(
                &mut self,
                params: ::flatbuffers::WIPOffset<
                    ::flatbuffers::Vector<'b, ::flatbuffers::ForwardsUOffset<Parameter<'b>>>,
                >,
            ) {
                self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(
                    FunctionSignature::VT_PARAMS,
                    params,
                );
            }
            #[inline]
            pub fn add_returns(
                &mut self,
                returns: ::flatbuffers::WIPOffset<
                    ::flatbuffers::Vector<'b, ::flatbuffers::ForwardsUOffset<ReturnType<'b>>>,
                >,
            ) {
                self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(
                    FunctionSignature::VT_RETURNS,
                    returns,
                );
            }
            #[inline]
            pub fn add_is_variadic(&mut self, is_variadic: bool) {
                self.fbb_
                    .push_slot::<bool>(FunctionSignature::VT_IS_VARIADIC, is_variadic, false);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> FunctionSignatureBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                FunctionSignatureBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> ::flatbuffers::WIPOffset<FunctionSignature<'a>> {
                let o = self.fbb_.end_table(self.start_);
                ::flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl ::core::fmt::Debug for FunctionSignature<'_> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut ds = f.debug_struct("FunctionSignature");
                ds.field("params", &self.params());
                ds.field("returns", &self.returns());
                ds.field("is_variadic", &self.is_variadic());
                ds.finish()
            }
        }
        pub enum FunctionOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct Function<'a> {
            pub _tab: ::flatbuffers::Table<'a>,
        }

        impl<'a> ::flatbuffers::Follow<'a> for Function<'a> {
            type Inner = Function<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: unsafe { ::flatbuffers::Table::new(buf, loc) },
                }
            }
        }

        impl<'a> Function<'a> {
            pub const VT_NAME: ::flatbuffers::VOffsetT = 4;
            pub const VT_QUALIFIED_NAME: ::flatbuffers::VOffsetT = 6;
            pub const VT_SIGNATURE: ::flatbuffers::VOffsetT = 8;
            pub const VT_BLOCKS: ::flatbuffers::VOffsetT = 10;
            pub const VT_SOURCE_POS: ::flatbuffers::VOffsetT = 12;
            pub const VT_IS_GENERATED: ::flatbuffers::VOffsetT = 14;
            pub const VT_DEFERS: ::flatbuffers::VOffsetT = 16;
            pub const VT_FREE_VARS: ::flatbuffers::VOffsetT = 18;
            pub const VT_IS_METHOD: ::flatbuffers::VOffsetT = 20;
            pub const VT_RECEIVER_TYPE: ::flatbuffers::VOffsetT = 22;

            #[inline]
            pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
                Function { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: ::flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args FunctionArgs<'args>,
            ) -> ::flatbuffers::WIPOffset<Function<'bldr>> {
                let mut builder = FunctionBuilder::new(_fbb);
                if let Some(x) = args.receiver_type {
                    builder.add_receiver_type(x);
                }
                if let Some(x) = args.free_vars {
                    builder.add_free_vars(x);
                }
                if let Some(x) = args.defers {
                    builder.add_defers(x);
                }
                if let Some(x) = args.source_pos {
                    builder.add_source_pos(x);
                }
                if let Some(x) = args.blocks {
                    builder.add_blocks(x);
                }
                if let Some(x) = args.signature {
                    builder.add_signature(x);
                }
                if let Some(x) = args.qualified_name {
                    builder.add_qualified_name(x);
                }
                if let Some(x) = args.name {
                    builder.add_name(x);
                }
                builder.add_is_method(args.is_method);
                builder.add_is_generated(args.is_generated);
                builder.finish()
            }

            #[inline]
            pub fn name(&self) -> Option<&'a str> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<::flatbuffers::ForwardsUOffset<&str>>(Function::VT_NAME, None)
                }
            }
            #[inline]
            pub fn qualified_name(&self) -> Option<&'a str> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(
                        Function::VT_QUALIFIED_NAME,
                        None,
                    )
                }
            }
            #[inline]
            pub fn signature(&self) -> Option<FunctionSignature<'a>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<::flatbuffers::ForwardsUOffset<FunctionSignature>>(
                            Function::VT_SIGNATURE,
                            None,
                        )
                }
            }
            #[inline]
            pub fn blocks(
                &self,
            ) -> Option<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<BasicBlock<'a>>>>
            {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<::flatbuffers::ForwardsUOffset<
                        ::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<BasicBlock>>,
                    >>(Function::VT_BLOCKS, None)
                }
            }
            #[inline]
            pub fn source_pos(&self) -> Option<SourcePos<'a>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<::flatbuffers::ForwardsUOffset<SourcePos>>(
                        Function::VT_SOURCE_POS,
                        None,
                    )
                }
            }
            #[inline]
            pub fn is_generated(&self) -> bool {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<bool>(Function::VT_IS_GENERATED, Some(false))
                        .unwrap()
                }
            }
            #[inline]
            pub fn defers(
                &self,
            ) -> Option<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<DeferInfo<'a>>>>
            {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<::flatbuffers::ForwardsUOffset<
                        ::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<DeferInfo>>,
                    >>(Function::VT_DEFERS, None)
                }
            }
            #[inline]
            pub fn free_vars(
                &self,
            ) -> Option<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<Variable<'a>>>>
            {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<::flatbuffers::ForwardsUOffset<
                        ::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<Variable>>,
                    >>(Function::VT_FREE_VARS, None)
                }
            }
            #[inline]
            pub fn is_method(&self) -> bool {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<bool>(Function::VT_IS_METHOD, Some(false))
                        .unwrap()
                }
            }
            #[inline]
            pub fn receiver_type(&self) -> Option<&'a str> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(
                        Function::VT_RECEIVER_TYPE,
                        None,
                    )
                }
            }
        }

        impl ::flatbuffers::Verifiable for Function<'_> {
            #[inline]
            fn run_verifier(
                v: &mut ::flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
                v.visit_table(pos)?
                    .visit_field::<::flatbuffers::ForwardsUOffset<&str>>(
                        "name",
                        Self::VT_NAME,
                        false,
                    )?
                    .visit_field::<::flatbuffers::ForwardsUOffset<&str>>(
                        "qualified_name",
                        Self::VT_QUALIFIED_NAME,
                        false,
                    )?
                    .visit_field::<::flatbuffers::ForwardsUOffset<FunctionSignature>>(
                        "signature",
                        Self::VT_SIGNATURE,
                        false,
                    )?
                    .visit_field::<::flatbuffers::ForwardsUOffset<
                        ::flatbuffers::Vector<'_, ::flatbuffers::ForwardsUOffset<BasicBlock>>,
                    >>("blocks", Self::VT_BLOCKS, false)?
                    .visit_field::<::flatbuffers::ForwardsUOffset<SourcePos>>(
                        "source_pos",
                        Self::VT_SOURCE_POS,
                        false,
                    )?
                    .visit_field::<bool>("is_generated", Self::VT_IS_GENERATED, false)?
                    .visit_field::<::flatbuffers::ForwardsUOffset<
                        ::flatbuffers::Vector<'_, ::flatbuffers::ForwardsUOffset<DeferInfo>>,
                    >>("defers", Self::VT_DEFERS, false)?
                    .visit_field::<::flatbuffers::ForwardsUOffset<
                        ::flatbuffers::Vector<'_, ::flatbuffers::ForwardsUOffset<Variable>>,
                    >>("free_vars", Self::VT_FREE_VARS, false)?
                    .visit_field::<bool>("is_method", Self::VT_IS_METHOD, false)?
                    .visit_field::<::flatbuffers::ForwardsUOffset<&str>>(
                        "receiver_type",
                        Self::VT_RECEIVER_TYPE,
                        false,
                    )?
                    .finish();
                Ok(())
            }
        }
        pub struct FunctionArgs<'a> {
            pub name: Option<::flatbuffers::WIPOffset<&'a str>>,
            pub qualified_name: Option<::flatbuffers::WIPOffset<&'a str>>,
            pub signature: Option<::flatbuffers::WIPOffset<FunctionSignature<'a>>>,
            pub blocks: Option<
                ::flatbuffers::WIPOffset<
                    ::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<BasicBlock<'a>>>,
                >,
            >,
            pub source_pos: Option<::flatbuffers::WIPOffset<SourcePos<'a>>>,
            pub is_generated: bool,
            pub defers: Option<
                ::flatbuffers::WIPOffset<
                    ::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<DeferInfo<'a>>>,
                >,
            >,
            pub free_vars: Option<
                ::flatbuffers::WIPOffset<
                    ::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<Variable<'a>>>,
                >,
            >,
            pub is_method: bool,
            pub receiver_type: Option<::flatbuffers::WIPOffset<&'a str>>,
        }
        impl<'a> Default for FunctionArgs<'a> {
            #[inline]
            fn default() -> Self {
                FunctionArgs {
                    name: None,
                    qualified_name: None,
                    signature: None,
                    blocks: None,
                    source_pos: None,
                    is_generated: false,
                    defers: None,
                    free_vars: None,
                    is_method: false,
                    receiver_type: None,
                }
            }
        }

        pub struct FunctionBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
            fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> FunctionBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_name(&mut self, name: ::flatbuffers::WIPOffset<&'b str>) {
                self.fbb_
                    .push_slot_always::<::flatbuffers::WIPOffset<_>>(Function::VT_NAME, name);
            }
            #[inline]
            pub fn add_qualified_name(
                &mut self,
                qualified_name: ::flatbuffers::WIPOffset<&'b str>,
            ) {
                self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(
                    Function::VT_QUALIFIED_NAME,
                    qualified_name,
                );
            }
            #[inline]
            pub fn add_signature(
                &mut self,
                signature: ::flatbuffers::WIPOffset<FunctionSignature<'b>>,
            ) {
                self.fbb_
                    .push_slot_always::<::flatbuffers::WIPOffset<FunctionSignature>>(
                        Function::VT_SIGNATURE,
                        signature,
                    );
            }
            #[inline]
            pub fn add_blocks(
                &mut self,
                blocks: ::flatbuffers::WIPOffset<
                    ::flatbuffers::Vector<'b, ::flatbuffers::ForwardsUOffset<BasicBlock<'b>>>,
                >,
            ) {
                self.fbb_
                    .push_slot_always::<::flatbuffers::WIPOffset<_>>(Function::VT_BLOCKS, blocks);
            }
            #[inline]
            pub fn add_source_pos(&mut self, source_pos: ::flatbuffers::WIPOffset<SourcePos<'b>>) {
                self.fbb_
                    .push_slot_always::<::flatbuffers::WIPOffset<SourcePos>>(
                        Function::VT_SOURCE_POS,
                        source_pos,
                    );
            }
            #[inline]
            pub fn add_is_generated(&mut self, is_generated: bool) {
                self.fbb_
                    .push_slot::<bool>(Function::VT_IS_GENERATED, is_generated, false);
            }
            #[inline]
            pub fn add_defers(
                &mut self,
                defers: ::flatbuffers::WIPOffset<
                    ::flatbuffers::Vector<'b, ::flatbuffers::ForwardsUOffset<DeferInfo<'b>>>,
                >,
            ) {
                self.fbb_
                    .push_slot_always::<::flatbuffers::WIPOffset<_>>(Function::VT_DEFERS, defers);
            }
            #[inline]
            pub fn add_free_vars(
                &mut self,
                free_vars: ::flatbuffers::WIPOffset<
                    ::flatbuffers::Vector<'b, ::flatbuffers::ForwardsUOffset<Variable<'b>>>,
                >,
            ) {
                self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(
                    Function::VT_FREE_VARS,
                    free_vars,
                );
            }
            #[inline]
            pub fn add_is_method(&mut self, is_method: bool) {
                self.fbb_
                    .push_slot::<bool>(Function::VT_IS_METHOD, is_method, false);
            }
            #[inline]
            pub fn add_receiver_type(&mut self, receiver_type: ::flatbuffers::WIPOffset<&'b str>) {
                self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(
                    Function::VT_RECEIVER_TYPE,
                    receiver_type,
                );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> FunctionBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                FunctionBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> ::flatbuffers::WIPOffset<Function<'a>> {
                let o = self.fbb_.end_table(self.start_);
                ::flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl ::core::fmt::Debug for Function<'_> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut ds = f.debug_struct("Function");
                ds.field("name", &self.name());
                ds.field("qualified_name", &self.qualified_name());
                ds.field("signature", &self.signature());
                ds.field("blocks", &self.blocks());
                ds.field("source_pos", &self.source_pos());
                ds.field("is_generated", &self.is_generated());
                ds.field("defers", &self.defers());
                ds.field("free_vars", &self.free_vars());
                ds.field("is_method", &self.is_method());
                ds.field("receiver_type", &self.receiver_type());
                ds.finish()
            }
        }
        pub enum PackageOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct Package<'a> {
            pub _tab: ::flatbuffers::Table<'a>,
        }

        impl<'a> ::flatbuffers::Follow<'a> for Package<'a> {
            type Inner = Package<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: unsafe { ::flatbuffers::Table::new(buf, loc) },
                }
            }
        }

        impl<'a> Package<'a> {
            pub const VT_PATH: ::flatbuffers::VOffsetT = 4;
            pub const VT_NAME: ::flatbuffers::VOffsetT = 6;
            pub const VT_FUNCTIONS: ::flatbuffers::VOffsetT = 8;
            pub const VT_GLOBAL_VARS: ::flatbuffers::VOffsetT = 10;
            pub const VT_IS_GENERATED: ::flatbuffers::VOffsetT = 12;

            #[inline]
            pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
                Package { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: ::flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args PackageArgs<'args>,
            ) -> ::flatbuffers::WIPOffset<Package<'bldr>> {
                let mut builder = PackageBuilder::new(_fbb);
                if let Some(x) = args.global_vars {
                    builder.add_global_vars(x);
                }
                if let Some(x) = args.functions {
                    builder.add_functions(x);
                }
                if let Some(x) = args.name {
                    builder.add_name(x);
                }
                if let Some(x) = args.path {
                    builder.add_path(x);
                }
                builder.add_is_generated(args.is_generated);
                builder.finish()
            }

            #[inline]
            pub fn path(&self) -> Option<&'a str> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<::flatbuffers::ForwardsUOffset<&str>>(Package::VT_PATH, None)
                }
            }
            #[inline]
            pub fn name(&self) -> Option<&'a str> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<::flatbuffers::ForwardsUOffset<&str>>(Package::VT_NAME, None)
                }
            }
            #[inline]
            pub fn functions(
                &self,
            ) -> Option<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<Function<'a>>>>
            {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<::flatbuffers::ForwardsUOffset<
                        ::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<Function>>,
                    >>(Package::VT_FUNCTIONS, None)
                }
            }
            #[inline]
            pub fn global_vars(
                &self,
            ) -> Option<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<Variable<'a>>>>
            {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<::flatbuffers::ForwardsUOffset<
                        ::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<Variable>>,
                    >>(Package::VT_GLOBAL_VARS, None)
                }
            }
            #[inline]
            pub fn is_generated(&self) -> bool {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<bool>(Package::VT_IS_GENERATED, Some(false))
                        .unwrap()
                }
            }
        }

        impl ::flatbuffers::Verifiable for Package<'_> {
            #[inline]
            fn run_verifier(
                v: &mut ::flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
                v.visit_table(pos)?
                    .visit_field::<::flatbuffers::ForwardsUOffset<&str>>(
                        "path",
                        Self::VT_PATH,
                        false,
                    )?
                    .visit_field::<::flatbuffers::ForwardsUOffset<&str>>(
                        "name",
                        Self::VT_NAME,
                        false,
                    )?
                    .visit_field::<::flatbuffers::ForwardsUOffset<
                        ::flatbuffers::Vector<'_, ::flatbuffers::ForwardsUOffset<Function>>,
                    >>("functions", Self::VT_FUNCTIONS, false)?
                    .visit_field::<::flatbuffers::ForwardsUOffset<
                        ::flatbuffers::Vector<'_, ::flatbuffers::ForwardsUOffset<Variable>>,
                    >>("global_vars", Self::VT_GLOBAL_VARS, false)?
                    .visit_field::<bool>("is_generated", Self::VT_IS_GENERATED, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct PackageArgs<'a> {
            pub path: Option<::flatbuffers::WIPOffset<&'a str>>,
            pub name: Option<::flatbuffers::WIPOffset<&'a str>>,
            pub functions: Option<
                ::flatbuffers::WIPOffset<
                    ::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<Function<'a>>>,
                >,
            >,
            pub global_vars: Option<
                ::flatbuffers::WIPOffset<
                    ::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<Variable<'a>>>,
                >,
            >,
            pub is_generated: bool,
        }
        impl<'a> Default for PackageArgs<'a> {
            #[inline]
            fn default() -> Self {
                PackageArgs {
                    path: None,
                    name: None,
                    functions: None,
                    global_vars: None,
                    is_generated: false,
                }
            }
        }

        pub struct PackageBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
            fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> PackageBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_path(&mut self, path: ::flatbuffers::WIPOffset<&'b str>) {
                self.fbb_
                    .push_slot_always::<::flatbuffers::WIPOffset<_>>(Package::VT_PATH, path);
            }
            #[inline]
            pub fn add_name(&mut self, name: ::flatbuffers::WIPOffset<&'b str>) {
                self.fbb_
                    .push_slot_always::<::flatbuffers::WIPOffset<_>>(Package::VT_NAME, name);
            }
            #[inline]
            pub fn add_functions(
                &mut self,
                functions: ::flatbuffers::WIPOffset<
                    ::flatbuffers::Vector<'b, ::flatbuffers::ForwardsUOffset<Function<'b>>>,
                >,
            ) {
                self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(
                    Package::VT_FUNCTIONS,
                    functions,
                );
            }
            #[inline]
            pub fn add_global_vars(
                &mut self,
                global_vars: ::flatbuffers::WIPOffset<
                    ::flatbuffers::Vector<'b, ::flatbuffers::ForwardsUOffset<Variable<'b>>>,
                >,
            ) {
                self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(
                    Package::VT_GLOBAL_VARS,
                    global_vars,
                );
            }
            #[inline]
            pub fn add_is_generated(&mut self, is_generated: bool) {
                self.fbb_
                    .push_slot::<bool>(Package::VT_IS_GENERATED, is_generated, false);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> PackageBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                PackageBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> ::flatbuffers::WIPOffset<Package<'a>> {
                let o = self.fbb_.end_table(self.start_);
                ::flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl ::core::fmt::Debug for Package<'_> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut ds = f.debug_struct("Package");
                ds.field("path", &self.path());
                ds.field("name", &self.name());
                ds.field("functions", &self.functions());
                ds.field("global_vars", &self.global_vars());
                ds.field("is_generated", &self.is_generated());
                ds.finish()
            }
        }
        pub enum CallEdgeOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct CallEdge<'a> {
            pub _tab: ::flatbuffers::Table<'a>,
        }

        impl<'a> ::flatbuffers::Follow<'a> for CallEdge<'a> {
            type Inner = CallEdge<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: unsafe { ::flatbuffers::Table::new(buf, loc) },
                }
            }
        }

        impl<'a> CallEdge<'a> {
            pub const VT_CALLER: ::flatbuffers::VOffsetT = 4;
            pub const VT_CALLEE: ::flatbuffers::VOffsetT = 6;
            pub const VT_CALL_SITE: ::flatbuffers::VOffsetT = 8;
            pub const VT_IS_STATIC: ::flatbuffers::VOffsetT = 10;
            pub const VT_IS_GO: ::flatbuffers::VOffsetT = 12;
            pub const VT_IS_DEFER: ::flatbuffers::VOffsetT = 14;

            #[inline]
            pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
                CallEdge { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: ::flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args CallEdgeArgs<'args>,
            ) -> ::flatbuffers::WIPOffset<CallEdge<'bldr>> {
                let mut builder = CallEdgeBuilder::new(_fbb);
                if let Some(x) = args.call_site {
                    builder.add_call_site(x);
                }
                if let Some(x) = args.callee {
                    builder.add_callee(x);
                }
                if let Some(x) = args.caller {
                    builder.add_caller(x);
                }
                builder.add_is_defer(args.is_defer);
                builder.add_is_go(args.is_go);
                builder.add_is_static(args.is_static);
                builder.finish()
            }

            #[inline]
            pub fn caller(&self) -> Option<&'a str> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<::flatbuffers::ForwardsUOffset<&str>>(CallEdge::VT_CALLER, None)
                }
            }
            #[inline]
            pub fn callee(&self) -> Option<&'a str> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<::flatbuffers::ForwardsUOffset<&str>>(CallEdge::VT_CALLEE, None)
                }
            }
            #[inline]
            pub fn call_site(&self) -> Option<SourcePos<'a>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<::flatbuffers::ForwardsUOffset<SourcePos>>(
                        CallEdge::VT_CALL_SITE,
                        None,
                    )
                }
            }
            #[inline]
            pub fn is_static(&self) -> bool {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<bool>(CallEdge::VT_IS_STATIC, Some(false))
                        .unwrap()
                }
            }
            #[inline]
            pub fn is_go(&self) -> bool {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<bool>(CallEdge::VT_IS_GO, Some(false))
                        .unwrap()
                }
            }
            #[inline]
            pub fn is_defer(&self) -> bool {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<bool>(CallEdge::VT_IS_DEFER, Some(false))
                        .unwrap()
                }
            }
        }

        impl ::flatbuffers::Verifiable for CallEdge<'_> {
            #[inline]
            fn run_verifier(
                v: &mut ::flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
                v.visit_table(pos)?
                    .visit_field::<::flatbuffers::ForwardsUOffset<&str>>(
                        "caller",
                        Self::VT_CALLER,
                        false,
                    )?
                    .visit_field::<::flatbuffers::ForwardsUOffset<&str>>(
                        "callee",
                        Self::VT_CALLEE,
                        false,
                    )?
                    .visit_field::<::flatbuffers::ForwardsUOffset<SourcePos>>(
                        "call_site",
                        Self::VT_CALL_SITE,
                        false,
                    )?
                    .visit_field::<bool>("is_static", Self::VT_IS_STATIC, false)?
                    .visit_field::<bool>("is_go", Self::VT_IS_GO, false)?
                    .visit_field::<bool>("is_defer", Self::VT_IS_DEFER, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct CallEdgeArgs<'a> {
            pub caller: Option<::flatbuffers::WIPOffset<&'a str>>,
            pub callee: Option<::flatbuffers::WIPOffset<&'a str>>,
            pub call_site: Option<::flatbuffers::WIPOffset<SourcePos<'a>>>,
            pub is_static: bool,
            pub is_go: bool,
            pub is_defer: bool,
        }
        impl<'a> Default for CallEdgeArgs<'a> {
            #[inline]
            fn default() -> Self {
                CallEdgeArgs {
                    caller: None,
                    callee: None,
                    call_site: None,
                    is_static: false,
                    is_go: false,
                    is_defer: false,
                }
            }
        }

        pub struct CallEdgeBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
            fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> CallEdgeBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_caller(&mut self, caller: ::flatbuffers::WIPOffset<&'b str>) {
                self.fbb_
                    .push_slot_always::<::flatbuffers::WIPOffset<_>>(CallEdge::VT_CALLER, caller);
            }
            #[inline]
            pub fn add_callee(&mut self, callee: ::flatbuffers::WIPOffset<&'b str>) {
                self.fbb_
                    .push_slot_always::<::flatbuffers::WIPOffset<_>>(CallEdge::VT_CALLEE, callee);
            }
            #[inline]
            pub fn add_call_site(&mut self, call_site: ::flatbuffers::WIPOffset<SourcePos<'b>>) {
                self.fbb_
                    .push_slot_always::<::flatbuffers::WIPOffset<SourcePos>>(
                        CallEdge::VT_CALL_SITE,
                        call_site,
                    );
            }
            #[inline]
            pub fn add_is_static(&mut self, is_static: bool) {
                self.fbb_
                    .push_slot::<bool>(CallEdge::VT_IS_STATIC, is_static, false);
            }
            #[inline]
            pub fn add_is_go(&mut self, is_go: bool) {
                self.fbb_
                    .push_slot::<bool>(CallEdge::VT_IS_GO, is_go, false);
            }
            #[inline]
            pub fn add_is_defer(&mut self, is_defer: bool) {
                self.fbb_
                    .push_slot::<bool>(CallEdge::VT_IS_DEFER, is_defer, false);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> CallEdgeBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                CallEdgeBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> ::flatbuffers::WIPOffset<CallEdge<'a>> {
                let o = self.fbb_.end_table(self.start_);
                ::flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl ::core::fmt::Debug for CallEdge<'_> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut ds = f.debug_struct("CallEdge");
                ds.field("caller", &self.caller());
                ds.field("callee", &self.callee());
                ds.field("call_site", &self.call_site());
                ds.field("is_static", &self.is_static());
                ds.field("is_go", &self.is_go());
                ds.field("is_defer", &self.is_defer());
                ds.finish()
            }
        }
        pub enum CallGraphOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct CallGraph<'a> {
            pub _tab: ::flatbuffers::Table<'a>,
        }

        impl<'a> ::flatbuffers::Follow<'a> for CallGraph<'a> {
            type Inner = CallGraph<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: unsafe { ::flatbuffers::Table::new(buf, loc) },
                }
            }
        }

        impl<'a> CallGraph<'a> {
            pub const VT_EDGES: ::flatbuffers::VOffsetT = 4;

            #[inline]
            pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
                CallGraph { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: ::flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args CallGraphArgs<'args>,
            ) -> ::flatbuffers::WIPOffset<CallGraph<'bldr>> {
                let mut builder = CallGraphBuilder::new(_fbb);
                if let Some(x) = args.edges {
                    builder.add_edges(x);
                }
                builder.finish()
            }

            #[inline]
            pub fn edges(
                &self,
            ) -> Option<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<CallEdge<'a>>>>
            {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<::flatbuffers::ForwardsUOffset<
                        ::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<CallEdge>>,
                    >>(CallGraph::VT_EDGES, None)
                }
            }
        }

        impl ::flatbuffers::Verifiable for CallGraph<'_> {
            #[inline]
            fn run_verifier(
                v: &mut ::flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
                v.visit_table(pos)?
                    .visit_field::<::flatbuffers::ForwardsUOffset<
                        ::flatbuffers::Vector<'_, ::flatbuffers::ForwardsUOffset<CallEdge>>,
                    >>("edges", Self::VT_EDGES, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct CallGraphArgs<'a> {
            pub edges: Option<
                ::flatbuffers::WIPOffset<
                    ::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<CallEdge<'a>>>,
                >,
            >,
        }
        impl<'a> Default for CallGraphArgs<'a> {
            #[inline]
            fn default() -> Self {
                CallGraphArgs { edges: None }
            }
        }

        pub struct CallGraphBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
            fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> CallGraphBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_edges(
                &mut self,
                edges: ::flatbuffers::WIPOffset<
                    ::flatbuffers::Vector<'b, ::flatbuffers::ForwardsUOffset<CallEdge<'b>>>,
                >,
            ) {
                self.fbb_
                    .push_slot_always::<::flatbuffers::WIPOffset<_>>(CallGraph::VT_EDGES, edges);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> CallGraphBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                CallGraphBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> ::flatbuffers::WIPOffset<CallGraph<'a>> {
                let o = self.fbb_.end_table(self.start_);
                ::flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl ::core::fmt::Debug for CallGraph<'_> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut ds = f.debug_struct("CallGraph");
                ds.field("edges", &self.edges());
                ds.finish()
            }
        }
        pub enum InterfaceEntryOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct InterfaceEntry<'a> {
            pub _tab: ::flatbuffers::Table<'a>,
        }

        impl<'a> ::flatbuffers::Follow<'a> for InterfaceEntry<'a> {
            type Inner = InterfaceEntry<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: unsafe { ::flatbuffers::Table::new(buf, loc) },
                }
            }
        }

        impl<'a> InterfaceEntry<'a> {
            pub const VT_INTERFACE_NAME: ::flatbuffers::VOffsetT = 4;
            pub const VT_IMPLEMENTORS: ::flatbuffers::VOffsetT = 6;
            pub const VT_METHODS: ::flatbuffers::VOffsetT = 8;

            #[inline]
            pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
                InterfaceEntry { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: ::flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args InterfaceEntryArgs<'args>,
            ) -> ::flatbuffers::WIPOffset<InterfaceEntry<'bldr>> {
                let mut builder = InterfaceEntryBuilder::new(_fbb);
                if let Some(x) = args.methods {
                    builder.add_methods(x);
                }
                if let Some(x) = args.implementors {
                    builder.add_implementors(x);
                }
                if let Some(x) = args.interface_name {
                    builder.add_interface_name(x);
                }
                builder.finish()
            }

            #[inline]
            pub fn interface_name(&self) -> Option<&'a str> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(
                        InterfaceEntry::VT_INTERFACE_NAME,
                        None,
                    )
                }
            }
            #[inline]
            pub fn implementors(
                &self,
            ) -> Option<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<&'a str>>>
            {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<::flatbuffers::ForwardsUOffset<
                        ::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<&'a str>>,
                    >>(InterfaceEntry::VT_IMPLEMENTORS, None)
                }
            }
            #[inline]
            pub fn methods(
                &self,
            ) -> Option<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<&'a str>>>
            {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<::flatbuffers::ForwardsUOffset<
                        ::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<&'a str>>,
                    >>(InterfaceEntry::VT_METHODS, None)
                }
            }
        }

        impl ::flatbuffers::Verifiable for InterfaceEntry<'_> {
            #[inline]
            fn run_verifier(
                v: &mut ::flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
                v.visit_table(pos)?
                    .visit_field::<::flatbuffers::ForwardsUOffset<&str>>(
                        "interface_name",
                        Self::VT_INTERFACE_NAME,
                        false,
                    )?
                    .visit_field::<::flatbuffers::ForwardsUOffset<
                        ::flatbuffers::Vector<'_, ::flatbuffers::ForwardsUOffset<&'_ str>>,
                    >>("implementors", Self::VT_IMPLEMENTORS, false)?
                    .visit_field::<::flatbuffers::ForwardsUOffset<
                        ::flatbuffers::Vector<'_, ::flatbuffers::ForwardsUOffset<&'_ str>>,
                    >>("methods", Self::VT_METHODS, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct InterfaceEntryArgs<'a> {
            pub interface_name: Option<::flatbuffers::WIPOffset<&'a str>>,
            pub implementors: Option<
                ::flatbuffers::WIPOffset<
                    ::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<&'a str>>,
                >,
            >,
            pub methods: Option<
                ::flatbuffers::WIPOffset<
                    ::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<&'a str>>,
                >,
            >,
        }
        impl<'a> Default for InterfaceEntryArgs<'a> {
            #[inline]
            fn default() -> Self {
                InterfaceEntryArgs {
                    interface_name: None,
                    implementors: None,
                    methods: None,
                }
            }
        }

        pub struct InterfaceEntryBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
            fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> InterfaceEntryBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_interface_name(
                &mut self,
                interface_name: ::flatbuffers::WIPOffset<&'b str>,
            ) {
                self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(
                    InterfaceEntry::VT_INTERFACE_NAME,
                    interface_name,
                );
            }
            #[inline]
            pub fn add_implementors(
                &mut self,
                implementors: ::flatbuffers::WIPOffset<
                    ::flatbuffers::Vector<'b, ::flatbuffers::ForwardsUOffset<&'b str>>,
                >,
            ) {
                self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(
                    InterfaceEntry::VT_IMPLEMENTORS,
                    implementors,
                );
            }
            #[inline]
            pub fn add_methods(
                &mut self,
                methods: ::flatbuffers::WIPOffset<
                    ::flatbuffers::Vector<'b, ::flatbuffers::ForwardsUOffset<&'b str>>,
                >,
            ) {
                self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(
                    InterfaceEntry::VT_METHODS,
                    methods,
                );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> InterfaceEntryBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                InterfaceEntryBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> ::flatbuffers::WIPOffset<InterfaceEntry<'a>> {
                let o = self.fbb_.end_table(self.start_);
                ::flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl ::core::fmt::Debug for InterfaceEntry<'_> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut ds = f.debug_struct("InterfaceEntry");
                ds.field("interface_name", &self.interface_name());
                ds.field("implementors", &self.implementors());
                ds.field("methods", &self.methods());
                ds.finish()
            }
        }
        pub enum InterfaceTableOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct InterfaceTable<'a> {
            pub _tab: ::flatbuffers::Table<'a>,
        }

        impl<'a> ::flatbuffers::Follow<'a> for InterfaceTable<'a> {
            type Inner = InterfaceTable<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: unsafe { ::flatbuffers::Table::new(buf, loc) },
                }
            }
        }

        impl<'a> InterfaceTable<'a> {
            pub const VT_ENTRIES: ::flatbuffers::VOffsetT = 4;

            #[inline]
            pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
                InterfaceTable { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: ::flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args InterfaceTableArgs<'args>,
            ) -> ::flatbuffers::WIPOffset<InterfaceTable<'bldr>> {
                let mut builder = InterfaceTableBuilder::new(_fbb);
                if let Some(x) = args.entries {
                    builder.add_entries(x);
                }
                builder.finish()
            }

            #[inline]
            pub fn entries(
                &self,
            ) -> Option<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<InterfaceEntry<'a>>>>
            {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<::flatbuffers::ForwardsUOffset<
                        ::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<InterfaceEntry>>,
                    >>(InterfaceTable::VT_ENTRIES, None)
                }
            }
        }

        impl ::flatbuffers::Verifiable for InterfaceTable<'_> {
            #[inline]
            fn run_verifier(
                v: &mut ::flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
                v.visit_table(pos)?
                    .visit_field::<::flatbuffers::ForwardsUOffset<
                        ::flatbuffers::Vector<'_, ::flatbuffers::ForwardsUOffset<InterfaceEntry>>,
                    >>("entries", Self::VT_ENTRIES, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct InterfaceTableArgs<'a> {
            pub entries: Option<
                ::flatbuffers::WIPOffset<
                    ::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<InterfaceEntry<'a>>>,
                >,
            >,
        }
        impl<'a> Default for InterfaceTableArgs<'a> {
            #[inline]
            fn default() -> Self {
                InterfaceTableArgs { entries: None }
            }
        }

        pub struct InterfaceTableBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
            fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> InterfaceTableBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_entries(
                &mut self,
                entries: ::flatbuffers::WIPOffset<
                    ::flatbuffers::Vector<'b, ::flatbuffers::ForwardsUOffset<InterfaceEntry<'b>>>,
                >,
            ) {
                self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(
                    InterfaceTable::VT_ENTRIES,
                    entries,
                );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> InterfaceTableBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                InterfaceTableBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> ::flatbuffers::WIPOffset<InterfaceTable<'a>> {
                let o = self.fbb_.end_table(self.start_);
                ::flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl ::core::fmt::Debug for InterfaceTable<'_> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut ds = f.debug_struct("InterfaceTable");
                ds.field("entries", &self.entries());
                ds.finish()
            }
        }
        pub enum EnumConstantOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct EnumConstant<'a> {
            pub _tab: ::flatbuffers::Table<'a>,
        }

        impl<'a> ::flatbuffers::Follow<'a> for EnumConstant<'a> {
            type Inner = EnumConstant<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: unsafe { ::flatbuffers::Table::new(buf, loc) },
                }
            }
        }

        impl<'a> EnumConstant<'a> {
            pub const VT_NAME: ::flatbuffers::VOffsetT = 4;
            pub const VT_VALUE: ::flatbuffers::VOffsetT = 6;

            #[inline]
            pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
                EnumConstant { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: ::flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args EnumConstantArgs<'args>,
            ) -> ::flatbuffers::WIPOffset<EnumConstant<'bldr>> {
                let mut builder = EnumConstantBuilder::new(_fbb);
                if let Some(x) = args.value {
                    builder.add_value(x);
                }
                if let Some(x) = args.name {
                    builder.add_name(x);
                }
                builder.finish()
            }

            #[inline]
            pub fn name(&self) -> Option<&'a str> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<::flatbuffers::ForwardsUOffset<&str>>(EnumConstant::VT_NAME, None)
                }
            }
            #[inline]
            pub fn value(&self) -> Option<&'a str> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<::flatbuffers::ForwardsUOffset<&str>>(EnumConstant::VT_VALUE, None)
                }
            }
        }

        impl ::flatbuffers::Verifiable for EnumConstant<'_> {
            #[inline]
            fn run_verifier(
                v: &mut ::flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
                v.visit_table(pos)?
                    .visit_field::<::flatbuffers::ForwardsUOffset<&str>>(
                        "name",
                        Self::VT_NAME,
                        false,
                    )?
                    .visit_field::<::flatbuffers::ForwardsUOffset<&str>>(
                        "value",
                        Self::VT_VALUE,
                        false,
                    )?
                    .finish();
                Ok(())
            }
        }
        pub struct EnumConstantArgs<'a> {
            pub name: Option<::flatbuffers::WIPOffset<&'a str>>,
            pub value: Option<::flatbuffers::WIPOffset<&'a str>>,
        }
        impl<'a> Default for EnumConstantArgs<'a> {
            #[inline]
            fn default() -> Self {
                EnumConstantArgs {
                    name: None,
                    value: None,
                }
            }
        }

        pub struct EnumConstantBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
            fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> EnumConstantBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_name(&mut self, name: ::flatbuffers::WIPOffset<&'b str>) {
                self.fbb_
                    .push_slot_always::<::flatbuffers::WIPOffset<_>>(EnumConstant::VT_NAME, name);
            }
            #[inline]
            pub fn add_value(&mut self, value: ::flatbuffers::WIPOffset<&'b str>) {
                self.fbb_
                    .push_slot_always::<::flatbuffers::WIPOffset<_>>(EnumConstant::VT_VALUE, value);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> EnumConstantBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                EnumConstantBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> ::flatbuffers::WIPOffset<EnumConstant<'a>> {
                let o = self.fbb_.end_table(self.start_);
                ::flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl ::core::fmt::Debug for EnumConstant<'_> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut ds = f.debug_struct("EnumConstant");
                ds.field("name", &self.name());
                ds.field("value", &self.value());
                ds.finish()
            }
        }
        pub enum EnumGroupOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct EnumGroup<'a> {
            pub _tab: ::flatbuffers::Table<'a>,
        }

        impl<'a> ::flatbuffers::Follow<'a> for EnumGroup<'a> {
            type Inner = EnumGroup<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: unsafe { ::flatbuffers::Table::new(buf, loc) },
                }
            }
        }

        impl<'a> EnumGroup<'a> {
            pub const VT_TYPE_NAME: ::flatbuffers::VOffsetT = 4;
            pub const VT_CONSTANTS: ::flatbuffers::VOffsetT = 6;

            #[inline]
            pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
                EnumGroup { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: ::flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args EnumGroupArgs<'args>,
            ) -> ::flatbuffers::WIPOffset<EnumGroup<'bldr>> {
                let mut builder = EnumGroupBuilder::new(_fbb);
                if let Some(x) = args.constants {
                    builder.add_constants(x);
                }
                if let Some(x) = args.type_name {
                    builder.add_type_name(x);
                }
                builder.finish()
            }

            #[inline]
            pub fn type_name(&self) -> Option<&'a str> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<::flatbuffers::ForwardsUOffset<&str>>(EnumGroup::VT_TYPE_NAME, None)
                }
            }
            #[inline]
            pub fn constants(
                &self,
            ) -> Option<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<EnumConstant<'a>>>>
            {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<::flatbuffers::ForwardsUOffset<
                        ::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<EnumConstant>>,
                    >>(EnumGroup::VT_CONSTANTS, None)
                }
            }
        }

        impl ::flatbuffers::Verifiable for EnumGroup<'_> {
            #[inline]
            fn run_verifier(
                v: &mut ::flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
                v.visit_table(pos)?
                    .visit_field::<::flatbuffers::ForwardsUOffset<&str>>(
                        "type_name",
                        Self::VT_TYPE_NAME,
                        false,
                    )?
                    .visit_field::<::flatbuffers::ForwardsUOffset<
                        ::flatbuffers::Vector<'_, ::flatbuffers::ForwardsUOffset<EnumConstant>>,
                    >>("constants", Self::VT_CONSTANTS, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct EnumGroupArgs<'a> {
            pub type_name: Option<::flatbuffers::WIPOffset<&'a str>>,
            pub constants: Option<
                ::flatbuffers::WIPOffset<
                    ::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<EnumConstant<'a>>>,
                >,
            >,
        }
        impl<'a> Default for EnumGroupArgs<'a> {
            #[inline]
            fn default() -> Self {
                EnumGroupArgs {
                    type_name: None,
                    constants: None,
                }
            }
        }

        pub struct EnumGroupBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
            fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> EnumGroupBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_type_name(&mut self, type_name: ::flatbuffers::WIPOffset<&'b str>) {
                self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(
                    EnumGroup::VT_TYPE_NAME,
                    type_name,
                );
            }
            #[inline]
            pub fn add_constants(
                &mut self,
                constants: ::flatbuffers::WIPOffset<
                    ::flatbuffers::Vector<'b, ::flatbuffers::ForwardsUOffset<EnumConstant<'b>>>,
                >,
            ) {
                self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(
                    EnumGroup::VT_CONSTANTS,
                    constants,
                );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> EnumGroupBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                EnumGroupBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> ::flatbuffers::WIPOffset<EnumGroup<'a>> {
                let o = self.fbb_.end_table(self.start_);
                ::flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl ::core::fmt::Debug for EnumGroup<'_> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut ds = f.debug_struct("EnumGroup");
                ds.field("type_name", &self.type_name());
                ds.field("constants", &self.constants());
                ds.finish()
            }
        }
        pub enum AnalysisResultOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct AnalysisResult<'a> {
            pub _tab: ::flatbuffers::Table<'a>,
        }

        impl<'a> ::flatbuffers::Follow<'a> for AnalysisResult<'a> {
            type Inner = AnalysisResult<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: unsafe { ::flatbuffers::Table::new(buf, loc) },
                }
            }
        }

        impl<'a> AnalysisResult<'a> {
            pub const VT_PACKAGES: ::flatbuffers::VOffsetT = 4;
            pub const VT_CALL_GRAPH: ::flatbuffers::VOffsetT = 6;
            pub const VT_INTERFACE_TABLE: ::flatbuffers::VOffsetT = 8;
            pub const VT_ENUM_GROUPS: ::flatbuffers::VOffsetT = 10;
            pub const VT_ERRORS: ::flatbuffers::VOffsetT = 12;
            pub const VT_GO_VERSION: ::flatbuffers::VOffsetT = 14;
            pub const VT_MODULE_PATH: ::flatbuffers::VOffsetT = 16;

            #[inline]
            pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
                AnalysisResult { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<
                'bldr: 'args,
                'args: 'mut_bldr,
                'mut_bldr,
                A: ::flatbuffers::Allocator + 'bldr,
            >(
                _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
                args: &'args AnalysisResultArgs<'args>,
            ) -> ::flatbuffers::WIPOffset<AnalysisResult<'bldr>> {
                let mut builder = AnalysisResultBuilder::new(_fbb);
                if let Some(x) = args.module_path {
                    builder.add_module_path(x);
                }
                if let Some(x) = args.go_version {
                    builder.add_go_version(x);
                }
                if let Some(x) = args.errors {
                    builder.add_errors(x);
                }
                if let Some(x) = args.enum_groups {
                    builder.add_enum_groups(x);
                }
                if let Some(x) = args.interface_table {
                    builder.add_interface_table(x);
                }
                if let Some(x) = args.call_graph {
                    builder.add_call_graph(x);
                }
                if let Some(x) = args.packages {
                    builder.add_packages(x);
                }
                builder.finish()
            }

            #[inline]
            pub fn packages(
                &self,
            ) -> Option<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<Package<'a>>>>
            {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<::flatbuffers::ForwardsUOffset<
                        ::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<Package>>,
                    >>(AnalysisResult::VT_PACKAGES, None)
                }
            }
            #[inline]
            pub fn call_graph(&self) -> Option<CallGraph<'a>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<::flatbuffers::ForwardsUOffset<CallGraph>>(
                        AnalysisResult::VT_CALL_GRAPH,
                        None,
                    )
                }
            }
            #[inline]
            pub fn interface_table(&self) -> Option<InterfaceTable<'a>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<::flatbuffers::ForwardsUOffset<InterfaceTable>>(
                            AnalysisResult::VT_INTERFACE_TABLE,
                            None,
                        )
                }
            }
            #[inline]
            pub fn enum_groups(
                &self,
            ) -> Option<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<EnumGroup<'a>>>>
            {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<::flatbuffers::ForwardsUOffset<
                        ::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<EnumGroup>>,
                    >>(AnalysisResult::VT_ENUM_GROUPS, None)
                }
            }
            #[inline]
            pub fn errors(
                &self,
            ) -> Option<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<BridgeError<'a>>>>
            {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<::flatbuffers::ForwardsUOffset<
                        ::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<BridgeError>>,
                    >>(AnalysisResult::VT_ERRORS, None)
                }
            }
            #[inline]
            pub fn go_version(&self) -> Option<&'a str> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(
                        AnalysisResult::VT_GO_VERSION,
                        None,
                    )
                }
            }
            #[inline]
            pub fn module_path(&self) -> Option<&'a str> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(
                        AnalysisResult::VT_MODULE_PATH,
                        None,
                    )
                }
            }
        }

        impl ::flatbuffers::Verifiable for AnalysisResult<'_> {
            #[inline]
            fn run_verifier(
                v: &mut ::flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
                v.visit_table(pos)?
                    .visit_field::<::flatbuffers::ForwardsUOffset<
                        ::flatbuffers::Vector<'_, ::flatbuffers::ForwardsUOffset<Package>>,
                    >>("packages", Self::VT_PACKAGES, false)?
                    .visit_field::<::flatbuffers::ForwardsUOffset<CallGraph>>(
                        "call_graph",
                        Self::VT_CALL_GRAPH,
                        false,
                    )?
                    .visit_field::<::flatbuffers::ForwardsUOffset<InterfaceTable>>(
                        "interface_table",
                        Self::VT_INTERFACE_TABLE,
                        false,
                    )?
                    .visit_field::<::flatbuffers::ForwardsUOffset<
                        ::flatbuffers::Vector<'_, ::flatbuffers::ForwardsUOffset<EnumGroup>>,
                    >>("enum_groups", Self::VT_ENUM_GROUPS, false)?
                    .visit_field::<::flatbuffers::ForwardsUOffset<
                        ::flatbuffers::Vector<'_, ::flatbuffers::ForwardsUOffset<BridgeError>>,
                    >>("errors", Self::VT_ERRORS, false)?
                    .visit_field::<::flatbuffers::ForwardsUOffset<&str>>(
                        "go_version",
                        Self::VT_GO_VERSION,
                        false,
                    )?
                    .visit_field::<::flatbuffers::ForwardsUOffset<&str>>(
                        "module_path",
                        Self::VT_MODULE_PATH,
                        false,
                    )?
                    .finish();
                Ok(())
            }
        }
        pub struct AnalysisResultArgs<'a> {
            pub packages: Option<
                ::flatbuffers::WIPOffset<
                    ::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<Package<'a>>>,
                >,
            >,
            pub call_graph: Option<::flatbuffers::WIPOffset<CallGraph<'a>>>,
            pub interface_table: Option<::flatbuffers::WIPOffset<InterfaceTable<'a>>>,
            pub enum_groups: Option<
                ::flatbuffers::WIPOffset<
                    ::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<EnumGroup<'a>>>,
                >,
            >,
            pub errors: Option<
                ::flatbuffers::WIPOffset<
                    ::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<BridgeError<'a>>>,
                >,
            >,
            pub go_version: Option<::flatbuffers::WIPOffset<&'a str>>,
            pub module_path: Option<::flatbuffers::WIPOffset<&'a str>>,
        }
        impl<'a> Default for AnalysisResultArgs<'a> {
            #[inline]
            fn default() -> Self {
                AnalysisResultArgs {
                    packages: None,
                    call_graph: None,
                    interface_table: None,
                    enum_groups: None,
                    errors: None,
                    go_version: None,
                    module_path: None,
                }
            }
        }

        pub struct AnalysisResultBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
            fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> AnalysisResultBuilder<'a, 'b, A> {
            #[inline]
            pub fn add_packages(
                &mut self,
                packages: ::flatbuffers::WIPOffset<
                    ::flatbuffers::Vector<'b, ::flatbuffers::ForwardsUOffset<Package<'b>>>,
                >,
            ) {
                self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(
                    AnalysisResult::VT_PACKAGES,
                    packages,
                );
            }
            #[inline]
            pub fn add_call_graph(&mut self, call_graph: ::flatbuffers::WIPOffset<CallGraph<'b>>) {
                self.fbb_
                    .push_slot_always::<::flatbuffers::WIPOffset<CallGraph>>(
                        AnalysisResult::VT_CALL_GRAPH,
                        call_graph,
                    );
            }
            #[inline]
            pub fn add_interface_table(
                &mut self,
                interface_table: ::flatbuffers::WIPOffset<InterfaceTable<'b>>,
            ) {
                self.fbb_
                    .push_slot_always::<::flatbuffers::WIPOffset<InterfaceTable>>(
                        AnalysisResult::VT_INTERFACE_TABLE,
                        interface_table,
                    );
            }
            #[inline]
            pub fn add_enum_groups(
                &mut self,
                enum_groups: ::flatbuffers::WIPOffset<
                    ::flatbuffers::Vector<'b, ::flatbuffers::ForwardsUOffset<EnumGroup<'b>>>,
                >,
            ) {
                self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(
                    AnalysisResult::VT_ENUM_GROUPS,
                    enum_groups,
                );
            }
            #[inline]
            pub fn add_errors(
                &mut self,
                errors: ::flatbuffers::WIPOffset<
                    ::flatbuffers::Vector<'b, ::flatbuffers::ForwardsUOffset<BridgeError<'b>>>,
                >,
            ) {
                self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(
                    AnalysisResult::VT_ERRORS,
                    errors,
                );
            }
            #[inline]
            pub fn add_go_version(&mut self, go_version: ::flatbuffers::WIPOffset<&'b str>) {
                self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(
                    AnalysisResult::VT_GO_VERSION,
                    go_version,
                );
            }
            #[inline]
            pub fn add_module_path(&mut self, module_path: ::flatbuffers::WIPOffset<&'b str>) {
                self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(
                    AnalysisResult::VT_MODULE_PATH,
                    module_path,
                );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            ) -> AnalysisResultBuilder<'a, 'b, A> {
                let start = _fbb.start_table();
                AnalysisResultBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> ::flatbuffers::WIPOffset<AnalysisResult<'a>> {
                let o = self.fbb_.end_table(self.start_);
                ::flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl ::core::fmt::Debug for AnalysisResult<'_> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                let mut ds = f.debug_struct("AnalysisResult");
                ds.field("packages", &self.packages());
                ds.field("call_graph", &self.call_graph());
                ds.field("interface_table", &self.interface_table());
                ds.field("enum_groups", &self.enum_groups());
                ds.field("errors", &self.errors());
                ds.field("go_version", &self.go_version());
                ds.field("module_path", &self.module_path());
                ds.finish()
            }
        }
        #[inline]
        /// Verifies that a buffer of bytes contains a `AnalysisResult`
        /// and returns it.
        /// Note that verification is still experimental and may not
        /// catch every error, or be maximally performant. For the
        /// previous, unchecked, behavior use
        /// `root_as_analysis_result_unchecked`.
        pub fn root_as_analysis_result(
            buf: &[u8],
        ) -> Result<AnalysisResult<'_>, ::flatbuffers::InvalidFlatbuffer> {
            ::flatbuffers::root::<AnalysisResult>(buf)
        }
        #[inline]
        /// Verifies that a buffer of bytes contains a size prefixed
        /// `AnalysisResult` and returns it.
        /// Note that verification is still experimental and may not
        /// catch every error, or be maximally performant. For the
        /// previous, unchecked, behavior use
        /// `size_prefixed_root_as_analysis_result_unchecked`.
        pub fn size_prefixed_root_as_analysis_result(
            buf: &[u8],
        ) -> Result<AnalysisResult<'_>, ::flatbuffers::InvalidFlatbuffer> {
            ::flatbuffers::size_prefixed_root::<AnalysisResult>(buf)
        }
        #[inline]
        /// Verifies, with the given options, that a buffer of bytes
        /// contains a `AnalysisResult` and returns it.
        /// Note that verification is still experimental and may not
        /// catch every error, or be maximally performant. For the
        /// previous, unchecked, behavior use
        /// `root_as_analysis_result_unchecked`.
        pub fn root_as_analysis_result_with_opts<'b, 'o>(
            opts: &'o ::flatbuffers::VerifierOptions,
            buf: &'b [u8],
        ) -> Result<AnalysisResult<'b>, ::flatbuffers::InvalidFlatbuffer> {
            ::flatbuffers::root_with_opts::<AnalysisResult<'b>>(opts, buf)
        }
        #[inline]
        /// Verifies, with the given verifier options, that a buffer of
        /// bytes contains a size prefixed `AnalysisResult` and returns
        /// it. Note that verification is still experimental and may not
        /// catch every error, or be maximally performant. For the
        /// previous, unchecked, behavior use
        /// `root_as_analysis_result_unchecked`.
        pub fn size_prefixed_root_as_analysis_result_with_opts<'b, 'o>(
            opts: &'o ::flatbuffers::VerifierOptions,
            buf: &'b [u8],
        ) -> Result<AnalysisResult<'b>, ::flatbuffers::InvalidFlatbuffer> {
            ::flatbuffers::size_prefixed_root_with_opts::<AnalysisResult<'b>>(opts, buf)
        }
        #[inline]
        /// Assumes, without verification, that a buffer of bytes contains a AnalysisResult and returns it.
        /// # Safety
        /// Callers must trust the given bytes do indeed contain a valid `AnalysisResult`.
        pub unsafe fn root_as_analysis_result_unchecked(buf: &[u8]) -> AnalysisResult<'_> {
            unsafe { ::flatbuffers::root_unchecked::<AnalysisResult>(buf) }
        }
        #[inline]
        /// Assumes, without verification, that a buffer of bytes contains a size prefixed AnalysisResult and returns it.
        /// # Safety
        /// Callers must trust the given bytes do indeed contain a valid size prefixed `AnalysisResult`.
        pub unsafe fn size_prefixed_root_as_analysis_result_unchecked(
            buf: &[u8],
        ) -> AnalysisResult<'_> {
            unsafe { ::flatbuffers::size_prefixed_root_unchecked::<AnalysisResult>(buf) }
        }
        #[inline]
        pub fn finish_analysis_result_buffer<'a, 'b, A: ::flatbuffers::Allocator + 'a>(
            fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            root: ::flatbuffers::WIPOffset<AnalysisResult<'a>>,
        ) {
            fbb.finish(root, None);
        }

        #[inline]
        pub fn finish_size_prefixed_analysis_result_buffer<
            'a,
            'b,
            A: ::flatbuffers::Allocator + 'a,
        >(
            fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
            root: ::flatbuffers::WIPOffset<AnalysisResult<'a>>,
        ) {
            fbb.finish_size_prefixed(root, None);
        }
    } // pub mod ir
} // pub mod goguard
